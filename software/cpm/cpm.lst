                                ;
                                ; Laser 500 CPM 2.2 CCP+CBIOS main file
                                ;
                                
                                MEM	        EQU	48		; KB RAM Left
                                STARTBIOS   EQU $BA00   ; start of bios in memory, called from boot loader
                                
                                IOBYTE            EQU $0003   ; IO byte
                                DEFDRIVE          EQU $0004   ; default drive
                                JUMPTOBDOS        EQU $0005   ; (3 bytes) JP BDOS
                                
                                include "ccp.calkins.asm"

                                ---------------------------------

                                ;**************************************************************
                                ;*
                                ;*             C P / M   version   2 . 2
                                ;*
                                ;*   Reconstructed from memory image on February 27, 1981
                                ;*
                                ;*                by Clark A. Calkins
                                ;*
                                ;**************************************************************
                                ;
                                ;   Set memory limit here. This is the amount of contigeous
                                ; ram starting from 0000. CP/M will reside at the end of this space.
                                ;
                                ;MEM	        EQU	48		;for a 62k system (TS802 TEST - WORKS OK).
                                ;STARTBIOS   EQU 0BA00H   ; start of bios in memory, called from boot loader
                                ;
                                ;IOBYTE	EQU	3		;i/o definition byte.
                                TDRIVE	EQU	4		;current drive name and user number.
                                ENTRY	EQU	5		;entry point for the cp/m bdos.
                                TFCB	EQU	5CH		;default file control block.
                                TBUFF	EQU	80H		;i/o buffer and command line storage.
                                TBASE	EQU	100H		;transiant program storage area.
                                ;
                                ;   Set control character equates.
                                ;
                                CNTRLC	EQU	3		;control-c
                                CNTRLE	EQU	05H		;control-e
                                BS	EQU	08H		;backspace
                                TAB	EQU	09H		;tab
                                LF	EQU	0AH		;line feed
                                FF	EQU	0CH		;form feed
                                CR	EQU	0DH		;carriage return
                                CNTRLP	EQU	10H		;control-p
                                CNTRLR	EQU	12H		;control-r
                                CNTRLS	EQU	13H		;control-s
                                CNTRLU	EQU	15H		;control-u
                                CNTRLX	EQU	18H		;control-x
                                CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
                                DEL	EQU	7FH		;rubout
                                ;
                                ;   Set origin for CP/M
                                ;
                                	ORG	(MEM-7)*1024
                                ;
A400: C3 5C A7                  CBASE:	JP	COMMAND		;execute command processor (ccp).
A403: C3 58 A7                  	JP	CLEARBUF	;entry to empty input buffer before starting ccp.
                                
                                ;
                                ;   Standard cp/m ccp input buffer. Format is (max length),
                                ; (actual length), (char #1), (char #2), (char #3), etc.
                                ;
A406: 7F                        INBUFF:	DB	127		;length of input buffer.
A407: 00                        	DB	0		;current length of contents.
A408: 43 6F 70 79 72 69 67 68   	DB	'Copyright'
A410: 74 
A411: 20 31 39 37 39 20 28 63   	DB	' 1979 (c) by Digital Research      '
A419: 29 20 62 79 20 44 69 67 
A421: 69 74 61 6C 20 52 65 73 
A429: 65 61 72 63 68 20 20 20 
A431: 20 20 20 
A434: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
A43C: 00 00 00 00 00 00 00 00 
A444: 00 00 00 00 00 00 00 
A44B: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
A453: 00 00 00 00 00 00 00 00 
A45B: 00 00 00 00 00 00 00 
A462: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
A46A: 00 00 00 00 00 00 00 00 
A472: 00 00 00 00 00 00 00 
A479: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
A481: 00 00 00 00 00 00 00 
A488: 08 A4                     INPOINT:DW	INBUFF+2	;input line pointer
A48A: 00 00                     NAMEPNT:DW	0		;input line pointer used for error message. Points to
                                ;			;start of name in error.
                                ;
                                ;   Routine to print (A) on the console. All registers used.
                                ;
A48C: 5F                        PRINT:	LD	E,A		;setup bdos call.
A48D: 0E 02                     	LD	C,2
A48F: C3 05 00                  	JP	ENTRY
                                ;
                                ;   Routine to print (A) on the console and to save (BC).
                                ;
A492: C5                        PRINTB:	PUSH	BC
A493: CD 8C A4                  	CALL	PRINT
A496: C1                        	POP	BC
A497: C9                        	RET	
                                ;
                                ;   Routine to send a carriage return, line feed combination
                                ; to the console.
                                ;
A498: 3E 0D                     CRLF:	LD	A,CR
A49A: CD 92 A4                  	CALL	PRINTB
A49D: 3E 0A                     	LD	A,LF
A49F: C3 92 A4                  	JP	PRINTB
                                ;
                                ;   Routine to send one space to the console and save (BC).
                                ;
A4A2: 3E 20                     SPACE:	LD	A,' '
A4A4: C3 92 A4                  	JP	PRINTB
                                ;
                                ;   Routine to print character string pointed to be (BC) on the
                                ; console. It must terminate with a null byte.
                                ;
A4A7: C5                        PLINE:	PUSH	BC
A4A8: CD 98 A4                  	CALL	CRLF
A4AB: E1                        	POP	HL
A4AC: 7E                        PLINE2:	LD	A,(HL)
A4AD: B7                        	OR	A
A4AE: C8                        	RET	Z
A4AF: 23                        	INC	HL
A4B0: E5                        	PUSH	HL
A4B1: CD 8C A4                  	CALL	PRINT
A4B4: E1                        	POP	HL
A4B5: C3 AC A4                  	JP	PLINE2
                                ;
                                ;   Routine to reset the disk system.
                                ;
A4B8: 0E 0D                     RESDSK:	LD	C,13
A4BA: C3 05 00                  	JP	ENTRY
                                ;
                                ;   Routine to select disk (A).
                                ;
A4BD: 5F                        DSKSEL:	LD	E,A
A4BE: 0E 0E                     	LD	C,14
A4C0: C3 05 00                  	JP	ENTRY
                                ;
                                ;   Routine to call bdos and save the return code. The zero
                                ; flag is set on a return of 0ffh.
                                ;
A4C3: CD 05 00                  ENTRY1:	CALL	ENTRY
A4C6: 32 EE AB                  	LD	(RTNCODE),A	;save return code.
A4C9: 3C                        	INC	A		;set zero if 0ffh returned.
A4CA: C9                        	RET	
                                ;
                                ;   Routine to open a file. (DE) must point to the FCB.
                                ;
A4CB: 0E 0F                     OPEN:	LD	C,15
A4CD: C3 C3 A4                  	JP	ENTRY1
                                ;
                                ;   Routine to open file at (FCB).
                                ;
A4D0: AF                        OPENFCB:XOR	A		;clear the record number byte at fcb+32
A4D1: 32 ED AB                  	LD	(FCB+32),A
A4D4: 11 CD AB                  	LD	DE,FCB
A4D7: C3 CB A4                  	JP	OPEN
                                ;
                                ;   Routine to close a file. (DE) points to FCB.
                                ;
A4DA: 0E 10                     CLOSE:	LD	C,16
A4DC: C3 C3 A4                  	JP	ENTRY1
                                ;
                                ;   Routine to search for the first file with ambigueous name
                                ; (DE).
                                ;
A4DF: 0E 11                     SRCHFST:LD	C,17
A4E1: C3 C3 A4                  	JP	ENTRY1
                                ;
                                ;   Search for the next ambigeous file name.
                                ;
A4E4: 0E 12                     SRCHNXT:LD	C,18
A4E6: C3 C3 A4                  	JP	ENTRY1
                                ;
                                ;   Search for file at (FCB).
                                ;
A4E9: 11 CD AB                  SRCHFCB:LD	DE,FCB
A4EC: C3 DF A4                  	JP	SRCHFST
                                ;
                                ;   Routine to delete a file pointed to by (DE).
                                ;
A4EF: 0E 13                     DELETE:	LD	C,19
A4F1: C3 05 00                  	JP	ENTRY
                                ;
                                ;   Routine to call the bdos and set the zero flag if a zero
                                ; status is returned.
                                ;
A4F4: CD 05 00                  ENTRY2:	CALL	ENTRY
A4F7: B7                        	OR	A		;set zero flag if appropriate.
A4F8: C9                        	RET	
                                ;
                                ;   Routine to read the next record from a sequential file.
                                ; (DE) points to the FCB.
                                ;
A4F9: 0E 14                     RDREC:	LD	C,20
A4FB: C3 F4 A4                  	JP	ENTRY2
                                ;
                                ;   Routine to read file at (FCB).
                                ;
A4FE: 11 CD AB                  READFCB:LD	DE,FCB
A501: C3 F9 A4                  	JP	RDREC
                                ;
                                ;   Routine to write the next record of a sequential file.
                                ; (DE) points to the FCB.
                                ;
A504: 0E 15                     WRTREC:	LD	C,21
A506: C3 F4 A4                  	JP	ENTRY2
                                ;
                                ;   Routine to create the file pointed to by (DE).
                                ;
A509: 0E 16                     CREATE:	LD	C,22
A50B: C3 C3 A4                  	JP	ENTRY1
                                ;
                                ;   Routine to rename the file pointed to by (DE). Note that
                                ; the new name starts at (DE+16).
                                ;
A50E: 0E 17                     RENAM:	LD	C,23
A510: C3 05 00                  	JP	ENTRY
                                ;
                                ;   Get the current user code.
                                ;
A513: 1E FF                     GETUSR:	LD	E,0FFH
                                ;
                                ;   Routne to get or set the current user code.
                                ; If (E) is FF then this is a GET, else it is a SET.
                                ;
A515: 0E 20                     GETSETUC: LD	C,32
A517: C3 05 00                  	JP	ENTRY
                                ;
                                ;   Routine to set the current drive byte at (TDRIVE).
                                ;
A51A: CD 13 A5                  SETCDRV:CALL	GETUSR		;get user number
A51D: 87                        	ADD	A,A		;and shift into the upper 4 bits.
A51E: 87                        	ADD	A,A
A51F: 87                        	ADD	A,A
A520: 87                        	ADD	A,A
A521: 21 EF AB                  	LD	HL,CDRIVE	;now add in the current drive number.
A524: B6                        	OR	(HL)
A525: 32 04 00                  	LD	(TDRIVE),A	;and save.
A528: C9                        	RET	
                                ;
                                ;   Move currently active drive down to (TDRIVE).
                                ;
A529: 3A EF AB                  MOVECD:	LD	A,(CDRIVE)
A52C: 32 04 00                  	LD	(TDRIVE),A
A52F: C9                        	RET	
                                ;
                                ;   Routine to convert (A) into upper case ascii. Only letters
                                ; are affected.
                                ;
A530: FE 61                     UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
A532: D8                        	RET	C
A533: FE 7B                     	CP	'{'
A535: D0                        	RET	NC
A536: E6 5F                     	AND	5FH		;convert it if found.
A538: C9                        	RET	
                                ;
                                ;   Routine to get a line of input. We must check to see if the
                                ; user is in (BATCH) mode. If so, then read the input from file
                                ; ($$$.SUB). At the end, reset to console input.
                                ;
A539: 3A AB AB                  GETINP:	LD	A,(BATCH)	;if =0, then use console input.
A53C: B7                        	OR	A
A53D: CA 96 A5                  	JP	Z,GETINP1
                                ;
                                ;   Use the submit file ($$$.sub) which is prepared by a
                                ; SUBMIT run. It must be on drive (A) and it will be deleted
                                ; if and error occures (like eof).
                                ;
A540: 3A EF AB                  	LD	A,(CDRIVE)	;select drive 0 if need be.
A543: B7                        	OR	A
A544: 3E 00                     	LD	A,0		;always use drive A for submit.
A546: C4 BD A4                  	CALL	NZ,DSKSEL	;select it if required.
A549: 11 AC AB                  	LD	DE,BATCHFCB
A54C: CD CB A4                  	CALL	OPEN		;look for it.
A54F: CA 96 A5                  	JP	Z,GETINP1	;if not there, use normal input.
A552: 3A BB AB                  	LD	A,(BATCHFCB+15)	;get last record number+1.
A555: 3D                        	DEC	A
A556: 32 CC AB                  	LD	(BATCHFCB+32),A
A559: 11 AC AB                  	LD	DE,BATCHFCB
A55C: CD F9 A4                  	CALL	RDREC		;read last record.
A55F: C2 96 A5                  	JP	NZ,GETINP1	;quit on end of file.
                                ;
                                ;   Move this record into input buffer.
                                ;
A562: 11 07 A4                  	LD	DE,INBUFF+1
A565: 21 80 00                  	LD	HL,TBUFF	;data was read into buffer here.
A568: 06 80                     	LD	B,128		;all 128 characters may be used.
A56A: CD 42 A8                  	CALL	HL2DE		;(HL) to (DE), (B) bytes.
A56D: 21 BA AB                  	LD	HL,BATCHFCB+14
A570: 36 00                     	LD	(HL),0		;zero out the 's2' byte.
A572: 23                        	INC	HL		;and decrement the record count.
A573: 35                        	DEC	(HL)
A574: 11 AC AB                  	LD	DE,BATCHFCB	;close the batch file now.
A577: CD DA A4                  	CALL	CLOSE
A57A: CA 96 A5                  	JP	Z,GETINP1	;quit on an error.
A57D: 3A EF AB                  	LD	A,(CDRIVE)	;re-select previous drive if need be.
A580: B7                        	OR	A
A581: C4 BD A4                  	CALL	NZ,DSKSEL	;don't do needless selects.
                                ;
                                ;   Print line just read on console.
                                ;
A584: 21 08 A4                  	LD	HL,INBUFF+2
A587: CD AC A4                  	CALL	PLINE2
A58A: CD C2 A5                  	CALL	CHKCON		;check console, quit on a key.
A58D: CA A7 A5                  	JP	Z,GETINP2	;jump if no key is pressed.
                                ;
                                ;   Terminate the submit job on any keyboard input. Delete this
                                ; file such that it is not re-started and jump to normal keyboard
                                ; input section.
                                ;
A590: CD DD A5                  	CALL	DELBATCH	;delete the batch file.
A593: C3 82 A7                  	JP	CMMND1		;and restart command input.
                                ;
                                ;   Get here for normal keyboard input. Delete the submit file
                                ; incase there was one.
                                ;
A596: CD DD A5                  GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
A599: CD 1A A5                  	CALL	SETCDRV		;reset active disk.
A59C: 0E 0A                     	LD	C,10		;get line from console device.
A59E: 11 06 A4                  	LD	DE,INBUFF
A5A1: CD 05 00                  	CALL	ENTRY
A5A4: CD 29 A5                  	CALL	MOVECD		;reset current drive (again).
                                ;
                                ;   Convert input line to upper case.
                                ;
A5A7: 21 07 A4                  GETINP2:LD	HL,INBUFF+1
A5AA: 46                        	LD	B,(HL)		;(B)=character counter.
A5AB: 23                        GETINP3:INC	HL
A5AC: 78                        	LD	A,B		;end of the line?
A5AD: B7                        	OR	A
A5AE: CA BA A5                  	JP	Z,GETINP4
A5B1: 7E                        	LD	A,(HL)		;convert to upper case.
A5B2: CD 30 A5                  	CALL	UPPER
A5B5: 77                        	LD	(HL),A
A5B6: 05                        	DEC	B		;adjust character count.
A5B7: C3 AB A5                  	JP	GETINP3
A5BA: 77                        GETINP4:LD	(HL),A		;add trailing null.
A5BB: 21 08 A4                  	LD	HL,INBUFF+2
A5BE: 22 88 A4                  	LD	(INPOINT),HL	;reset input line pointer.
A5C1: C9                        	RET	
                                ;
                                ;   Routine to check the console for a key pressed. The zero
                                ; flag is set is none, else the character is returned in (A).
                                ;
A5C2: 0E 0B                     CHKCON:	LD	C,11		;check console.
A5C4: CD 05 00                  	CALL	ENTRY
A5C7: B7                        	OR	A
A5C8: C8                        	RET	Z		;return if nothing.
A5C9: 0E 01                     	LD	C,1		;else get character.
A5CB: CD 05 00                  	CALL	ENTRY
A5CE: B7                        	OR	A		;clear zero flag and return.
A5CF: C9                        	RET	
                                ;
                                ;   Routine to get the currently active drive number.
                                ;
A5D0: 0E 19                     GETDSK:	LD	C,25
A5D2: C3 05 00                  	JP	ENTRY
                                ;
                                ;   Set the stabdard dma address.
                                ;
A5D5: 11 80 00                  STDDMA:	LD	DE,TBUFF
                                ;
                                ;   Routine to set the dma address to (DE).
                                ;
A5D8: 0E 1A                     DMASET:	LD	C,26
A5DA: C3 05 00                  	JP	ENTRY
                                ;
                                ;  Delete the batch file created by SUBMIT.
                                ;
A5DD: 21 AB AB                  DELBATCH: LD	HL,BATCH	;is batch active?
A5E0: 7E                        	LD	A,(HL)
A5E1: B7                        	OR	A
A5E2: C8                        	RET	Z
A5E3: 36 00                     	LD	(HL),0		;yes, de-activate it.
A5E5: AF                        	XOR	A
A5E6: CD BD A4                  	CALL	DSKSEL		;select drive 0 for sure.
A5E9: 11 AC AB                  	LD	DE,BATCHFCB	;and delete this file.
A5EC: CD EF A4                  	CALL	DELETE
A5EF: 3A EF AB                  	LD	A,(CDRIVE)	;reset current drive.
A5F2: C3 BD A4                  	JP	DSKSEL
                                ;
                                ;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
                                ; the same or we XALT....
                                ;
A5F5: 11 28 A7                  VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
A5F8: 21 00 AC                  	LD	HL,PATTRN2	;ditto, but how could they be different?
A5FB: 06 06                     	LD	B,6		;6 bytes each.
A5FD: 1A                        VERIFY1:LD	A,(DE)
A5FE: BE                        	CP	(HL)
A5FF: C2 CF A7                  	JP	NZ,XALT		;jump to XALT routine.
A602: 13                        	INC	DE
A603: 23                        	INC	HL
A604: 05                        	DEC	B
A605: C2 FD A5                  	JP	NZ,VERIFY1
A608: C9                        	RET	
                                ;
                                ;   Print back file name with a '?' to indicate a syntax error.
                                ;
A609: CD 98 A4                  SYNERR:	CALL	CRLF		;end current line.
A60C: 2A 8A A4                  	LD	HL,(NAMEPNT)	;this points to name in error.
A60F: 7E                        SYNERR1:LD	A,(HL)		;print it until a space or null is found.
A610: FE 20                     	CP	' '
A612: CA 22 A6                  	JP	Z,SYNERR2
A615: B7                        	OR	A
A616: CA 22 A6                  	JP	Z,SYNERR2
A619: E5                        	PUSH	HL
A61A: CD 8C A4                  	CALL	PRINT
A61D: E1                        	POP	HL
A61E: 23                        	INC	HL
A61F: C3 0F A6                  	JP	SYNERR1
A622: 3E 3F                     SYNERR2:LD	A,'?'		;add trailing '?'.
A624: CD 8C A4                  	CALL	PRINT
A627: CD 98 A4                  	CALL	CRLF
A62A: CD DD A5                  	CALL	DELBATCH	;delete any batch file.
A62D: C3 82 A7                  	JP	CMMND1		;and restart from console input.
                                ;
                                ;   Check character at (DE) for legal command input. Note that the
                                ; zero flag is set if the character is a delimiter.
                                ;
A630: 1A                        CHECK:	LD	A,(DE)
A631: B7                        	OR	A
A632: C8                        	RET	Z
A633: FE 20                     	CP	' '		;control characters are not legal here.
A635: DA 09 A6                  	JP	C,SYNERR
A638: C8                        	RET	Z		;check for valid delimiter.
A639: FE 3D                     	CP	'='
A63B: C8                        	RET	Z
A63C: FE 5F                     	CP	'_'
A63E: C8                        	RET	Z
A63F: FE 2E                     	CP	'.'
A641: C8                        	RET	Z
A642: FE 3A                     	CP	':'
A644: C8                        	RET	Z
A645: FE 3B                     	CP	';'
A647: C8                        	RET	Z
A648: FE 3C                     	CP	'<'
A64A: C8                        	RET	Z
A64B: FE 3E                     	CP	'>'
A64D: C8                        	RET	Z
A64E: C9                        	RET	
                                ;
                                ;   Get the next non-blank character from (DE).
                                ;
A64F: 1A                        NONBLANK: LD	A,(DE)
A650: B7                        	OR	A		;string ends with a null.
A651: C8                        	RET	Z
A652: FE 20                     	CP	' '
A654: C0                        	RET	NZ
A655: 13                        	INC	DE
A656: C3 4F A6                  	JP	NONBLANK
                                ;
                                ;   Add (HL)=(HL)+(A)
                                ;
A659: 85                        ADDHL:	ADD	A,L
A65A: 6F                        	LD	L,A
A65B: D0                        	RET	NC		;take care of any carry.
A65C: 24                        	INC	H
A65D: C9                        	RET	
                                ;
                                ;   Convert the first name in (FCB).
                                ;
A65E: 3E 00                     CONVFST:LD	A,0
                                ;
                                ;   Format a file name (convert * to '?', etc.). On return,
                                ; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
                                ; the position within the fcb for the name (either 0 or 16).
                                ;
A660: 21 CD AB                  CONVERT:LD	HL,FCB
A663: CD 59 A6                  	CALL	ADDHL
A666: E5                        	PUSH	HL
A667: E5                        	PUSH	HL
A668: AF                        	XOR	A
A669: 32 F0 AB                  	LD	(CHGDRV),A	;initialize drive change flag.
A66C: 2A 88 A4                  	LD	HL,(INPOINT)	;set (HL) as pointer into input line.
A66F: EB                        	EX	DE,HL
A670: CD 4F A6                  	CALL	NONBLANK	;get next non-blank character.
A673: EB                        	EX	DE,HL
A674: 22 8A A4                  	LD	(NAMEPNT),HL	;save pointer here for any error message.
A677: EB                        	EX	DE,HL
A678: E1                        	POP	HL
A679: 1A                        	LD	A,(DE)		;get first character.
A67A: B7                        	OR	A
A67B: CA 89 A6                  	JP	Z,CONVRT1
A67E: DE 40                     	SBC	A,'A'-1		;might be a drive name, convert to binary.
A680: 47                        	LD	B,A		;and save.
A681: 13                        	INC	DE		;check next character for a ':'.
A682: 1A                        	LD	A,(DE)
A683: FE 3A                     	CP	':'
A685: CA 90 A6                  	JP	Z,CONVRT2
A688: 1B                        	DEC	DE		;nope, move pointer back to the start of the line.
A689: 3A EF AB                  CONVRT1:LD	A,(CDRIVE)
A68C: 77                        	LD	(HL),A
A68D: C3 96 A6                  	JP	CONVRT3
A690: 78                        CONVRT2:LD	A,B
A691: 32 F0 AB                  	LD	(CHGDRV),A	;set change in drives flag.
A694: 70                        	LD	(HL),B
A695: 13                        	INC	DE
                                ;
                                ;   Convert the basic file name.
                                ;
A696: 06 08                     CONVRT3:LD	B,08H
A698: CD 30 A6                  CONVRT4:CALL	CHECK
A69B: CA B9 A6                  	JP	Z,CONVRT8
A69E: 23                        	INC	HL
A69F: FE 2A                     	CP	'*'		;note that an '*' will fill the remaining
A6A1: C2 A9 A6                  	JP	NZ,CONVRT5	;field with '?'.
A6A4: 36 3F                     	LD	(HL),'?'
A6A6: C3 AB A6                  	JP	CONVRT6
A6A9: 77                        CONVRT5:LD	(HL),A
A6AA: 13                        	INC	DE
A6AB: 05                        CONVRT6:DEC	B
A6AC: C2 98 A6                  	JP	NZ,CONVRT4
A6AF: CD 30 A6                  CONVRT7:CALL	CHECK		;get next delimiter.
A6B2: CA C0 A6                  	JP	Z,GETEXT
A6B5: 13                        	INC	DE
A6B6: C3 AF A6                  	JP	CONVRT7
A6B9: 23                        CONVRT8:INC	HL		;blank fill the file name.
A6BA: 36 20                     	LD	(HL),' '
A6BC: 05                        	DEC	B
A6BD: C2 B9 A6                  	JP	NZ,CONVRT8
                                ;
                                ;   Get the extension and convert it.
                                ;
A6C0: 06 03                     GETEXT:	LD	B,03H
A6C2: FE 2E                     	CP	'.'
A6C4: C2 E9 A6                  	JP	NZ,GETEXT5
A6C7: 13                        	INC	DE
A6C8: CD 30 A6                  GETEXT1:CALL	CHECK
A6CB: CA E9 A6                  	JP	Z,GETEXT5
A6CE: 23                        	INC	HL
A6CF: FE 2A                     	CP	'*'
A6D1: C2 D9 A6                  	JP	NZ,GETEXT2
A6D4: 36 3F                     	LD	(HL),'?'
A6D6: C3 DB A6                  	JP	GETEXT3
A6D9: 77                        GETEXT2:LD	(HL),A
A6DA: 13                        	INC	DE
A6DB: 05                        GETEXT3:DEC	B
A6DC: C2 C8 A6                  	JP	NZ,GETEXT1
A6DF: CD 30 A6                  GETEXT4:CALL	CHECK
A6E2: CA F0 A6                  	JP	Z,GETEXT6
A6E5: 13                        	INC	DE
A6E6: C3 DF A6                  	JP	GETEXT4
A6E9: 23                        GETEXT5:INC	HL
A6EA: 36 20                     	LD	(HL),' '
A6EC: 05                        	DEC	B
A6ED: C2 E9 A6                  	JP	NZ,GETEXT5
A6F0: 06 03                     GETEXT6:LD	B,3
A6F2: 23                        GETEXT7:INC	HL
A6F3: 36 00                     	LD	(HL),0
A6F5: 05                        	DEC	B
A6F6: C2 F2 A6                  	JP	NZ,GETEXT7
A6F9: EB                        	EX	DE,HL
A6FA: 22 88 A4                  	LD	(INPOINT),HL	;save input line pointer.
A6FD: E1                        	POP	HL
                                ;
                                ;   Check to see if this is an ambigeous file name specification.
                                ; Set the (A) register to non zero if it is.
                                ;
A6FE: 01 0B 00                  	LD	BC,11		;set name length.
A701: 23                        GETEXT8:INC	HL
A702: 7E                        	LD	A,(HL)
A703: FE 3F                     	CP	'?'		;any question marks?
A705: C2 09 A7                  	JP	NZ,GETEXT9
A708: 04                        	INC	B		;count them.
A709: 0D                        GETEXT9:DEC	C
A70A: C2 01 A7                  	JP	NZ,GETEXT8
A70D: 78                        	LD	A,B
A70E: B7                        	OR	A
A70F: C9                        	RET	
                                ;
                                ;   CP/M command table. Note commands can be either 3 or 4 characters long.
                                ;
                                NUMCMDS EQU	6		;number of commands
A710: 44 49 52 20               CMDTBL:	DB	'DIR '
A714: 45 52 41 20               	DB	'ERA '
A718: 54 59 50 45               	DB	'TYPE'
A71C: 53 41 56 45               	DB	'SAVE'
A720: 52 45 4E 20               	DB	'REN '
A724: 55 53 45 52               	DB	'USER'
                                ;
                                ;   The following six bytes must agree with those at (PATTRN2)
                                ; or cp/m will XALT. Why?
                                ;
A728: 00 16 00 00 00 00         PATTRN1:DB	0,22,0,0,0,0	;(* serial number bytes *).
                                ;
                                ;   Search the command table for a match with what has just
                                ; been entered. If a match is found, then we jump to the
                                ; proper section. Else jump to (UNKNOWN).
                                ; On return, the (C) register is set to the command number
                                ; that matched (or NUMCMDS+1 if no match).
                                ;
A72E: 21 10 A7                  SEARCH:	LD	HL,CMDTBL
A731: 0E 00                     	LD	C,0
A733: 79                        SEARCH1:LD	A,C
A734: FE 06                     	CP	NUMCMDS		;this commands exists.
A736: D0                        	RET	NC
A737: 11 CE AB                  	LD	DE,FCB+1	;check this one.
A73A: 06 04                     	LD	B,4		;max command length.
A73C: 1A                        SEARCH2:LD	A,(DE)
A73D: BE                        	CP	(HL)
A73E: C2 4F A7                  	JP	NZ,SEARCH3	;not a match.
A741: 13                        	INC	DE
A742: 23                        	INC	HL
A743: 05                        	DEC	B
A744: C2 3C A7                  	JP	NZ,SEARCH2
A747: 1A                        	LD	A,(DE)		;allow a 3 character command to match.
A748: FE 20                     	CP	' '
A74A: C2 54 A7                  	JP	NZ,SEARCH4
A74D: 79                        	LD	A,C		;set return register for this command.
A74E: C9                        	RET	
A74F: 23                        SEARCH3:INC	HL
A750: 05                        	DEC	B
A751: C2 4F A7                  	JP	NZ,SEARCH3
A754: 0C                        SEARCH4:INC	C
A755: C3 33 A7                  	JP	SEARCH1
                                ;
                                ;   Set the input buffer to empty and then start the command
                                ; processor (ccp).
                                ;
A758: AF                        CLEARBUF: XOR	A
A759: 32 07 A4                  	LD	(INBUFF+1),A	;second byte is actual length.
                                ;
                                ;**************************************************************
                                ;*
                                ;*
                                ;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
                                ;*
                                ;**************************************************************
                                ;*
A75C: 31 AB AB                  COMMAND:LD	SP,CCPSTACK	;setup stack area.
A75F: C5                        	PUSH	BC		;note that (C) should be equal to:
A760: 79                        	LD	A,C		;(uuuudddd) where 'uuuu' is the user number
A761: 1F                        	RRA			;and 'dddd' is the drive number.
A762: 1F                        	RRA	
A763: 1F                        	RRA	
A764: 1F                        	RRA	
A765: E6 0F                     	AND	0FH		;isolate the user number.
A767: 5F                        	LD	E,A
A768: CD 15 A5                  	CALL	GETSETUC	;and set it.
A76B: CD B8 A4                  	CALL	RESDSK		;reset the disk system.
A76E: 32 AB AB                  	LD	(BATCH),A	;clear batch mode flag.
A771: C1                        	POP	BC
A772: 79                        	LD	A,C
A773: E6 0F                     	AND	0FH		;isolate the drive number.
A775: 32 EF AB                  	LD	(CDRIVE),A	;and save.
A778: CD BD A4                  	CALL	DSKSEL		;...and select.
A77B: 3A 07 A4                  	LD	A,(INBUFF+1)
A77E: B7                        	OR	A		;anything in input buffer already?
A77F: C2 98 A7                  	JP	NZ,CMMND2	;yes, we just process it.
                                ;
                                ;   Entry point to get a command line from the console.
                                ;
A782: 31 AB AB                  CMMND1:	LD	SP,CCPSTACK	;set stack straight.
A785: CD 98 A4                  	CALL	CRLF		;start a new line on the screen.
A788: CD D0 A5                  	CALL	GETDSK		;get current drive.
A78B: C6 61                     	ADD	A,'a'
A78D: CD 8C A4                  	CALL	PRINT		;print current drive.
A790: 3E 3E                     	LD	A,'>'
A792: CD 8C A4                  	CALL	PRINT		;and add prompt.
A795: CD 39 A5                  	CALL	GETINP		;get line from user.
                                ;
                                ;   Process command line here.
                                ;
A798: 11 80 00                  CMMND2:	LD	DE,TBUFF
A79B: CD D8 A5                  	CALL	DMASET		;set standard dma address.
A79E: CD D0 A5                  	CALL	GETDSK
A7A1: 32 EF AB                  	LD	(CDRIVE),A	;set current drive.
A7A4: CD 5E A6                  	CALL	CONVFST		;convert name typed in.
A7A7: C4 09 A6                  	CALL	NZ,SYNERR	;wild cards are not allowed.
A7AA: 3A F0 AB                  	LD	A,(CHGDRV)	;if a change in drives was indicated,
A7AD: B7                        	OR	A		;then treat this as an unknown command
A7AE: C2 A5 AA                  	JP	NZ,UNKNOWN	;which gets executed.
A7B1: CD 2E A7                  	CALL	SEARCH		;else search command table for a match.
                                ;
                                ;   Note that an unknown command returns
                                ; with (A) pointing to the last address
                                ; in our table which is (UNKNOWN).
                                ;
A7B4: 21 C1 A7                  	LD	HL,CMDADR	;now, look thru our address table for command (A).
A7B7: 5F                        	LD	E,A		;set (DE) to command number.
A7B8: 16 00                     	LD	D,0
A7BA: 19                        	ADD	HL,DE
A7BB: 19                        	ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
A7BC: 7E                        	LD	A,(HL)		;now pick out this address.
A7BD: 23                        	INC	HL
A7BE: 66                        	LD	H,(HL)
A7BF: 6F                        	LD	L,A
A7C0: E9                        	JP	(HL)		;now execute it.
                                ;
                                ;   CP/M command address table.
                                ;
A7C1: 77 A8 1F A9 5D A9 AD A9   CMDADR:	DW	DIRECT,ERASE,TYPE,SAVE
A7C9: 10 AA 8E AA A5 AA         	DW	RENAME,USER,UNKNOWN
                                ;
                                ;   XALT the system. Reason for this is unknown at present.
                                ;
A7CF: 21 F3 76                  XALT:	LD	HL,76F3H	;'DI HLT' instructions.
A7D2: 22 00 A4                  	LD	(CBASE),HL
A7D5: 21 00 A4                  	LD	HL,CBASE
A7D8: E9                        	JP	(HL)
                                ;
                                ;   Read error while TYPEing a file.
                                ;
A7D9: 01 DF A7                  RDERROR:LD	BC,RDERR
A7DC: C3 A7 A4                  	JP	PLINE
A7DF: 52 65 61 64 20 65 72 72   RDERR:	DB	'Read error',0
A7E7: 6F 72 00 
                                ;
                                ;   Required file was not located.
                                ;
A7EA: 01 F0 A7                  NONE:	LD	BC,NOFILE
A7ED: C3 A7 A4                  	JP	PLINE
A7F0: 4E 6F 20 66 69 6C 65 00   NOFILE:	DB	'No file',0
                                ;
                                ;   Decode a command of the form 'A>filename number{ filename}.
                                ; Note that a drive specifier is not allowed on the first file
                                ; name. On return, the number is in register (A). Any error
                                ; causes 'filename?' to be printed and the command is aborted.
                                ;
A7F8: CD 5E A6                  DECODE:	CALL	CONVFST		;convert filename.
A7FB: 3A F0 AB                  	LD	A,(CHGDRV)	;do not allow a drive to be specified.
A7FE: B7                        	OR	A
A7FF: C2 09 A6                  	JP	NZ,SYNERR
A802: 21 CE AB                  	LD	HL,FCB+1	;convert number now.
A805: 01 0B 00                  	LD	BC,11		;(B)=sum register, (C)=max digit count.
A808: 7E                        DECODE1:LD	A,(HL)
A809: FE 20                     	CP	' '		;a space terminates the numeral.
A80B: CA 33 A8                  	JP	Z,DECODE3
A80E: 23                        	INC	HL
A80F: D6 30                     	SUB	'0'		;make binary from ascii.
A811: FE 0A                     	CP	10		;legal digit?
A813: D2 09 A6                  	JP	NC,SYNERR
A816: 57                        	LD	D,A		;yes, save it in (D).
A817: 78                        	LD	A,B		;compute (B)=(B)*10 and check for overflow.
A818: E6 E0                     	AND	0E0H
A81A: C2 09 A6                  	JP	NZ,SYNERR
A81D: 78                        	LD	A,B
A81E: 07                        	RLCA	
A81F: 07                        	RLCA	
A820: 07                        	RLCA			;(A)=(B)*8
A821: 80                        	ADD	A,B		;.......*9
A822: DA 09 A6                  	JP	C,SYNERR
A825: 80                        	ADD	A,B		;.......*10
A826: DA 09 A6                  	JP	C,SYNERR
A829: 82                        	ADD	A,D		;add in new digit now.
A82A: DA 09 A6                  DECODE2:JP	C,SYNERR
A82D: 47                        	LD	B,A		;and save result.
A82E: 0D                        	DEC	C		;only look at 11 digits.
A82F: C2 08 A8                  	JP	NZ,DECODE1
A832: C9                        	RET	
A833: 7E                        DECODE3:LD	A,(HL)		;spaces must follow (why?).
A834: FE 20                     	CP	' '
A836: C2 09 A6                  	JP	NZ,SYNERR
A839: 23                        	INC	HL
A83A: 0D                        DECODE4:DEC	C
A83B: C2 33 A8                  	JP	NZ,DECODE3
A83E: 78                        	LD	A,B		;set (A)=the numeric value entered.
A83F: C9                        	RET	
                                ;
                                ;   Move 3 bytes from (HL) to (DE). Note that there is only
                                ; one reference to this at (A2D5h).
                                ;
A840: 06 03                     MOVE3:	LD	B,3
                                ;
                                ;   Move (B) bytes from (HL) to (DE).
                                ;
A842: 7E                        HL2DE:	LD	A,(HL)
A843: 12                        	LD	(DE),A
A844: 23                        	INC	HL
A845: 13                        	INC	DE
A846: 05                        	DEC	B
A847: C2 42 A8                  	JP	NZ,HL2DE
A84A: C9                        	RET	
                                ;
                                ;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
                                ;
A84B: 21 80 00                  EXTRACT:LD	HL,TBUFF
A84E: 81                        	ADD	A,C
A84F: CD 59 A6                  	CALL	ADDHL
A852: 7E                        	LD	A,(HL)
A853: C9                        	RET	
                                ;
                                ;  Check drive specified. If it means a change, then the new
                                ; drive will be selected. In any case, the drive byte of the
                                ; fcb will be set to null (means use current drive).
                                ;
A854: AF                        DSELECT:XOR	A		;null out first byte of fcb.
A855: 32 CD AB                  	LD	(FCB),A
A858: 3A F0 AB                  	LD	A,(CHGDRV)	;a drive change indicated?
A85B: B7                        	OR	A
A85C: C8                        	RET	Z
A85D: 3D                        	DEC	A		;yes, is it the same as the current drive?
A85E: 21 EF AB                  	LD	HL,CDRIVE
A861: BE                        	CP	(HL)
A862: C8                        	RET	Z
A863: C3 BD A4                  	JP	DSKSEL		;no. Select it then.
                                ;
                                ;   Check the drive selection and reset it to the previous
                                ; drive if it was changed for the preceeding command.
                                ;
A866: 3A F0 AB                  RESETDR:LD	A,(CHGDRV)	;drive change indicated?
A869: B7                        	OR	A
A86A: C8                        	RET	Z
A86B: 3D                        	DEC	A		;yes, was it a different drive?
A86C: 21 EF AB                  	LD	HL,CDRIVE
A86F: BE                        	CP	(HL)
A870: C8                        	RET	Z
A871: 3A EF AB                  	LD	A,(CDRIVE)	;yes, re-select our old drive.
A874: C3 BD A4                  	JP	DSKSEL
                                ;
                                ;**************************************************************
                                ;*
                                ;*           D I R E C T O R Y   C O M M A N D
                                ;*
                                ;**************************************************************
                                ;
A877: CD 5E A6                  DIRECT:	CALL	CONVFST		;convert file name.
A87A: CD 54 A8                  	CALL	DSELECT		;select indicated drive.
A87D: 21 CE AB                  	LD	HL,FCB+1	;was any file indicated?
A880: 7E                        	LD	A,(HL)
A881: FE 20                     	CP	' '
A883: C2 8F A8                  	JP	NZ,DIRECT2
A886: 06 0B                     	LD	B,11		;no. Fill field with '?' - same as *.*.
A888: 36 3F                     DIRECT1:LD	(HL),'?'
A88A: 23                        	INC	HL
A88B: 05                        	DEC	B
A88C: C2 88 A8                  	JP	NZ,DIRECT1
A88F: 1E 00                     DIRECT2:LD	E,0		;set initial cursor position.
A891: D5                        	PUSH	DE
A892: CD E9 A4                  	CALL	SRCHFCB		;get first file name.
A895: CC EA A7                  	CALL	Z,NONE		;none found at all?
A898: CA 1B A9                  DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
A89B: 3A EE AB                  	LD	A,(RTNCODE)	;get file's position in segment (0-3).
A89E: 0F                        	RRCA	
A89F: 0F                        	RRCA	
A8A0: 0F                        	RRCA	
A8A1: E6 60                     	AND	60H		;(A)=position*32
A8A3: 4F                        	LD	C,A
A8A4: 3E 0A                     	LD	A,10
A8A6: CD 4B A8                  	CALL	EXTRACT		;extract the tenth entry in fcb.
A8A9: 17                        	RLA			;check system file status bit.
A8AA: DA 0F A9                  	JP	C,DIRECT8	;we don't list them.
A8AD: D1                        	POP	DE
A8AE: 7B                        	LD	A,E		;bump name count.
A8AF: 1C                        	INC	E
A8B0: D5                        	PUSH	DE
A8B1: E6 03                     	AND	03H		;at end of line?
A8B3: F5                        	PUSH	AF
A8B4: C2 CC A8                  	JP	NZ,DIRECT4
A8B7: CD 98 A4                  	CALL	CRLF		;yes, end this line and start another.
A8BA: C5                        	PUSH	BC
A8BB: CD D0 A5                  	CALL	GETDSK		;start line with ('A:').
A8BE: C1                        	POP	BC
A8BF: C6 41                     	ADD	A,'A'
A8C1: CD 92 A4                  	CALL	PRINTB
A8C4: 3E 3A                     	LD	A,':'
A8C6: CD 92 A4                  	CALL	PRINTB
A8C9: C3 D4 A8                  	JP	DIRECT5
A8CC: CD A2 A4                  DIRECT4:CALL	SPACE		;add seperator between file names.
A8CF: 3E 3A                     	LD	A,':'
A8D1: CD 92 A4                  	CALL	PRINTB
A8D4: CD A2 A4                  DIRECT5:CALL	SPACE
A8D7: 06 01                     	LD	B,1		;'extract' each file name character at a time.
A8D9: 78                        DIRECT6:LD	A,B
A8DA: CD 4B A8                  	CALL	EXTRACT
A8DD: E6 7F                     	AND	7FH		;strip bit 7 (status bit).
A8DF: FE 20                     	CP	' '		;are we at the end of the name?
A8E1: C2 F9 A8                  	JP	NZ,DRECT65
A8E4: F1                        	POP	AF		;yes, don't print spaces at the end of a line.
A8E5: F5                        	PUSH	AF
A8E6: FE 03                     	CP	3
A8E8: C2 F7 A8                  	JP	NZ,DRECT63
A8EB: 3E 09                     	LD	A,9		;first check for no extension.
A8ED: CD 4B A8                  	CALL	EXTRACT
A8F0: E6 7F                     	AND	7FH
A8F2: FE 20                     	CP	' '
A8F4: CA 0E A9                  	JP	Z,DIRECT7	;don't print spaces.
A8F7: 3E 20                     DRECT63:LD	A,' '		;else print them.
A8F9: CD 92 A4                  DRECT65:CALL	PRINTB
A8FC: 04                        	INC	B		;bump to next character psoition.
A8FD: 78                        	LD	A,B
A8FE: FE 0C                     	CP	12		;end of the name?
A900: D2 0E A9                  	JP	NC,DIRECT7
A903: FE 09                     	CP	9		;nope, starting extension?
A905: C2 D9 A8                  	JP	NZ,DIRECT6
A908: CD A2 A4                  	CALL	SPACE		;yes, add seperating space.
A90B: C3 D9 A8                  	JP	DIRECT6
A90E: F1                        DIRECT7:POP	AF		;get the next file name.
A90F: CD C2 A5                  DIRECT8:CALL	CHKCON		;first check console, quit on anything.
A912: C2 1B A9                  	JP	NZ,DIRECT9
A915: CD E4 A4                  	CALL	SRCHNXT		;get next name.
A918: C3 98 A8                  	JP	DIRECT3		;and continue with our list.
A91B: D1                        DIRECT9:POP	DE		;restore the stack and return to command level.
A91C: C3 86 AB                  	JP	GETBACK
                                ;
                                ;**************************************************************
                                ;*
                                ;*                E R A S E   C O M M A N D
                                ;*
                                ;**************************************************************
                                ;
A91F: CD 5E A6                  ERASE:	CALL	CONVFST		;convert file name.
A922: FE 0B                     	CP	11		;was '*.*' entered?
A924: C2 42 A9                  	JP	NZ,ERASE1
A927: 01 52 A9                  	LD	BC,YESNO	;yes, ask for confirmation.
A92A: CD A7 A4                  	CALL	PLINE
A92D: CD 39 A5                  	CALL	GETINP
A930: 21 07 A4                  	LD	HL,INBUFF+1
A933: 35                        	DEC	(HL)		;must be exactly 'y'.
A934: C2 82 A7                  	JP	NZ,CMMND1
A937: 23                        	INC	HL
A938: 7E                        	LD	A,(HL)
A939: FE 59                     	CP	'Y'
A93B: C2 82 A7                  	JP	NZ,CMMND1
A93E: 23                        	INC	HL
A93F: 22 88 A4                  	LD	(INPOINT),HL	;save input line pointer.
A942: CD 54 A8                  ERASE1:	CALL	DSELECT		;select desired disk.
A945: 11 CD AB                  	LD	DE,FCB
A948: CD EF A4                  	CALL	DELETE		;delete the file.
A94B: 3C                        	INC	A
A94C: CC EA A7                  	CALL	Z,NONE		;not there?
A94F: C3 86 AB                  	JP	GETBACK		;return to command level now.
A952: 41 6C 6C 20 28 79 2F 6E   YESNO:	DB	'All (y/n)?',0
A95A: 29 3F 00 
                                ;
                                ;**************************************************************
                                ;*
                                ;*            T Y P E   C O M M A N D
                                ;*
                                ;**************************************************************
                                ;
A95D: CD 5E A6                  TYPE:	CALL	CONVFST		;convert file name.
A960: C2 09 A6                  	JP	NZ,SYNERR	;wild cards not allowed.
A963: CD 54 A8                  	CALL	DSELECT		;select indicated drive.
A966: CD D0 A4                  	CALL	OPENFCB		;open the file.
A969: CA A7 A9                  	JP	Z,TYPE5		;not there?
A96C: CD 98 A4                  	CALL	CRLF		;ok, start a new line on the screen.
A96F: 21 F1 AB                  	LD	HL,NBYTES	;initialize byte counter.
A972: 36 FF                     	LD	(HL),0FFH	;set to read first sector.
A974: 21 F1 AB                  TYPE1:	LD	HL,NBYTES
A977: 7E                        TYPE2:	LD	A,(HL)		;have we written the entire sector?
A978: FE 80                     	CP	128
A97A: DA 87 A9                  	JP	C,TYPE3
A97D: E5                        	PUSH	HL		;yes, read in the next one.
A97E: CD FE A4                  	CALL	READFCB
A981: E1                        	POP	HL
A982: C2 A0 A9                  	JP	NZ,TYPE4	;end or error?
A985: AF                        	XOR	A		;ok, clear byte counter.
A986: 77                        	LD	(HL),A
A987: 34                        TYPE3:	INC	(HL)		;count this byte.
A988: 21 80 00                  	LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
A98B: CD 59 A6                  	CALL	ADDHL
A98E: 7E                        	LD	A,(HL)
A98F: FE 1A                     	CP	CNTRLZ		;end of file mark?
A991: CA 86 AB                  	JP	Z,GETBACK
A994: CD 8C A4                  	CALL	PRINT		;no, print it.
A997: CD C2 A5                  	CALL	CHKCON		;check console, quit if anything ready.
A99A: C2 86 AB                  	JP	NZ,GETBACK
A99D: C3 74 A9                  	JP	TYPE1
                                ;
                                ;   Get here on an end of file or read error.
                                ;
A9A0: 3D                        TYPE4:	DEC	A		;read error?
A9A1: CA 86 AB                  	JP	Z,GETBACK
A9A4: CD D9 A7                  	CALL	RDERROR		;yes, print message.
A9A7: CD 66 A8                  TYPE5:	CALL	RESETDR		;and reset proper drive
A9AA: C3 09 A6                  	JP	SYNERR		;now print file name with problem.
                                ;
                                ;**************************************************************
                                ;*
                                ;*            S A V E   C O M M A N D
                                ;*
                                ;**************************************************************
                                ;
A9AD: CD F8 A7                  SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
A9B0: F5                        	PUSH	AF		;save number of pages to write.
A9B1: CD 5E A6                  	CALL	CONVFST		;convert file name.
A9B4: C2 09 A6                  	JP	NZ,SYNERR	;wild cards not allowed.
A9B7: CD 54 A8                  	CALL	DSELECT		;select specified drive.
A9BA: 11 CD AB                  	LD	DE,FCB		;now delete this file.
A9BD: D5                        	PUSH	DE
A9BE: CD EF A4                  	CALL	DELETE
A9C1: D1                        	POP	DE
A9C2: CD 09 A5                  	CALL	CREATE		;and create it again.
A9C5: CA FB A9                  	JP	Z,SAVE3		;can't create?
A9C8: AF                        	XOR	A		;clear record number byte.
A9C9: 32 ED AB                  	LD	(FCB+32),A
A9CC: F1                        	POP	AF		;convert pages to sectors.
A9CD: 6F                        	LD	L,A
A9CE: 26 00                     	LD	H,0
A9D0: 29                        	ADD	HL,HL		;(HL)=number of sectors to write.
A9D1: 11 00 01                  	LD	DE,TBASE	;and we start from here.
A9D4: 7C                        SAVE1:	LD	A,H		;done yet?
A9D5: B5                        	OR	L
A9D6: CA F1 A9                  	JP	Z,SAVE2
A9D9: 2B                        	DEC	HL		;nope, count this and compute the start
A9DA: E5                        	PUSH	HL		;of the next 128 byte sector.
A9DB: 21 80 00                  	LD	HL,128
A9DE: 19                        	ADD	HL,DE
A9DF: E5                        	PUSH	HL		;save it and set the transfer address.
A9E0: CD D8 A5                  	CALL	DMASET
A9E3: 11 CD AB                  	LD	DE,FCB		;write out this sector now.
A9E6: CD 04 A5                  	CALL	WRTREC
A9E9: D1                        	POP	DE		;reset (DE) to the start of the last sector.
A9EA: E1                        	POP	HL		;restore sector count.
A9EB: C2 FB A9                  	JP	NZ,SAVE3	;write error?
A9EE: C3 D4 A9                  	JP	SAVE1
                                ;
                                ;   Get here after writing all of the file.
                                ;
A9F1: 11 CD AB                  SAVE2:	LD	DE,FCB		;now close the file.
A9F4: CD DA A4                  	CALL	CLOSE
A9F7: 3C                        	INC	A		;did it close ok?
A9F8: C2 01 AA                  	JP	NZ,SAVE4
                                ;
                                ;   Print out error message (no space).
                                ;
A9FB: 01 07 AA                  SAVE3:	LD	BC,NOSPACE
A9FE: CD A7 A4                  	CALL	PLINE
AA01: CD D5 A5                  SAVE4:	CALL	STDDMA		;reset the standard dma address.
AA04: C3 86 AB                  	JP	GETBACK
AA07: 4E 6F 20 73 70 61 63 65   NOSPACE:DB	'No space',0
AA0F: 00 
                                ;
                                ;**************************************************************
                                ;*
                                ;*           R E N A M E   C O M M A N D
                                ;*
                                ;**************************************************************
                                ;
AA10: CD 5E A6                  RENAME:	CALL	CONVFST		;convert first file name.
AA13: C2 09 A6                  	JP	NZ,SYNERR	;wild cards not allowed.
AA16: 3A F0 AB                  	LD	A,(CHGDRV)	;remember any change in drives specified.
AA19: F5                        	PUSH	AF
AA1A: CD 54 A8                  	CALL	DSELECT		;and select this drive.
AA1D: CD E9 A4                  	CALL	SRCHFCB		;is this file present?
AA20: C2 79 AA                  	JP	NZ,RENAME6	;yes, print error message.
AA23: 21 CD AB                  	LD	HL,FCB		;yes, move this name into second slot.
AA26: 11 DD AB                  	LD	DE,FCB+16
AA29: 06 10                     	LD	B,16
AA2B: CD 42 A8                  	CALL	HL2DE
AA2E: 2A 88 A4                  	LD	HL,(INPOINT)	;get input pointer.
AA31: EB                        	EX	DE,HL
AA32: CD 4F A6                  	CALL	NONBLANK	;get next non blank character.
AA35: FE 3D                     	CP	'='		;only allow an '=' or '_' seperator.
AA37: CA 3F AA                  	JP	Z,RENAME1
AA3A: FE 5F                     	CP	'_'
AA3C: C2 73 AA                  	JP	NZ,RENAME5
AA3F: EB                        RENAME1:EX	DE,HL
AA40: 23                        	INC	HL		;ok, skip seperator.
AA41: 22 88 A4                  	LD	(INPOINT),HL	;save input line pointer.
AA44: CD 5E A6                  	CALL	CONVFST		;convert this second file name now.
AA47: C2 73 AA                  	JP	NZ,RENAME5	;again, no wild cards.
AA4A: F1                        	POP	AF		;if a drive was specified, then it
AA4B: 47                        	LD	B,A		;must be the same as before.
AA4C: 21 F0 AB                  	LD	HL,CHGDRV
AA4F: 7E                        	LD	A,(HL)
AA50: B7                        	OR	A
AA51: CA 59 AA                  	JP	Z,RENAME2
AA54: B8                        	CP	B
AA55: 70                        	LD	(HL),B
AA56: C2 73 AA                  	JP	NZ,RENAME5	;they were different, error.
AA59: 70                        RENAME2:LD	(HL),B		;	reset as per the first file specification.
AA5A: AF                        	XOR	A
AA5B: 32 CD AB                  	LD	(FCB),A		;clear the drive byte of the fcb.
AA5E: CD E9 A4                  RENAME3:CALL	SRCHFCB		;and go look for second file.
AA61: CA 6D AA                  	JP	Z,RENAME4	;doesn't exist?
AA64: 11 CD AB                  	LD	DE,FCB
AA67: CD 0E A5                  	CALL	RENAM		;ok, rename the file.
AA6A: C3 86 AB                  	JP	GETBACK
                                ;
                                ;   Process rename errors here.
                                ;
AA6D: CD EA A7                  RENAME4:CALL	NONE		;file not there.
AA70: C3 86 AB                  	JP	GETBACK
AA73: CD 66 A8                  RENAME5:CALL	RESETDR		;bad command format.
AA76: C3 09 A6                  	JP	SYNERR
AA79: 01 82 AA                  RENAME6:LD	BC,EXISTS	;destination file already exists.
AA7C: CD A7 A4                  	CALL	PLINE
AA7F: C3 86 AB                  	JP	GETBACK
AA82: 46 69 6C 65 20 65 78 69   EXISTS:	DB	'File exists',0
AA8A: 73 74 73 00 
                                ;
                                ;**************************************************************
                                ;*
                                ;*             U S E R   C O M M A N D
                                ;*
                                ;**************************************************************
                                ;
AA8E: CD F8 A7                  USER:	CALL	DECODE		;get numeric value following command.
AA91: FE 10                     	CP	16		;legal user number?
AA93: D2 09 A6                  	JP	NC,SYNERR
AA96: 5F                        	LD	E,A		;yes but is there anything else?
AA97: 3A CE AB                  	LD	A,(FCB+1)
AA9A: FE 20                     	CP	' '
AA9C: CA 09 A6                  	JP	Z,SYNERR	;yes, that is not allowed.
AA9F: CD 15 A5                  	CALL	GETSETUC	;ok, set user code.
AAA2: C3 89 AB                  	JP	GETBACK1
                                ;
                                ;**************************************************************
                                ;*
                                ;*        T R A N S I A N T   P R O G R A M   C O M M A N D
                                ;*
                                ;**************************************************************
                                ;
AAA5: CD F5 A5                  UNKNOWN:CALL	VERIFY		;check for valid system (why?).
AAA8: 3A CE AB                  	LD	A,(FCB+1)	;anything to execute?
AAAB: FE 20                     	CP	' '
AAAD: C2 C4 AA                  	JP	NZ,UNKWN1
AAB0: 3A F0 AB                  	LD	A,(CHGDRV)	;nope, only a drive change?
AAB3: B7                        	OR	A
AAB4: CA 89 AB                  	JP	Z,GETBACK1	;neither???
AAB7: 3D                        	DEC	A
AAB8: 32 EF AB                  	LD	(CDRIVE),A	;ok, store new drive.
AABB: CD 29 A5                  	CALL	MOVECD		;set (TDRIVE) also.
AABE: CD BD A4                  	CALL	DSKSEL		;and select this drive.
AAC1: C3 89 AB                  	JP	GETBACK1	;then return.
                                ;
                                ;   Here a file name was typed. Prepare to execute it.
                                ;
AAC4: 11 D6 AB                  UNKWN1:	LD	DE,FCB+9	;an extension specified?
AAC7: 1A                        	LD	A,(DE)
AAC8: FE 20                     	CP	' '
AACA: C2 09 A6                  	JP	NZ,SYNERR	;yes, not allowed.
AACD: D5                        UNKWN2:	PUSH	DE
AACE: CD 54 A8                  	CALL	DSELECT		;select specified drive.
AAD1: D1                        	POP	DE
AAD2: 21 83 AB                  	LD	HL,COMFILE	;set the extension to 'COM'.
AAD5: CD 40 A8                  	CALL	MOVE3
AAD8: CD D0 A4                  	CALL	OPENFCB		;and open this file.
AADB: CA 6B AB                  	JP	Z,UNKWN9	;not present?
                                ;
                                ;   Load in the program.
                                ;
AADE: 21 00 01                  	LD	HL,TBASE	;store the program starting here.
AAE1: E5                        UNKWN3:	PUSH	HL
AAE2: EB                        	EX	DE,HL
AAE3: CD D8 A5                  	CALL	DMASET		;set transfer address.
AAE6: 11 CD AB                  	LD	DE,FCB		;and read the next record.
AAE9: CD F9 A4                  	CALL	RDREC
AAEC: C2 01 AB                  	JP	NZ,UNKWN4	;end of file or read error?
AAEF: E1                        	POP	HL		;nope, bump pointer for next sector.
AAF0: 11 80 00                  	LD	DE,128
AAF3: 19                        	ADD	HL,DE
AAF4: 11 00 A4                  	LD	DE,CBASE	;enough room for the whole file?
AAF7: 7D                        	LD	A,L
AAF8: 93                        	SUB	E
AAF9: 7C                        	LD	A,H
AAFA: 9A                        	SBC	A,D
AAFB: D2 71 AB                  	JP	NC,UNKWN0	;no, it can't fit.
AAFE: C3 E1 AA                  	JP	UNKWN3
                                ;
                                ;   Get here after finished reading.
                                ;
AB01: E1                        UNKWN4:	POP	HL
AB02: 3D                        	DEC	A		;normal end of file?
AB03: C2 71 AB                  	JP	NZ,UNKWN0
AB06: CD 66 A8                  	CALL	RESETDR		;yes, reset previous drive.
AB09: CD 5E A6                  	CALL	CONVFST		;convert the first file name that follows
AB0C: 21 F0 AB                  	LD	HL,CHGDRV	;command name.
AB0F: E5                        	PUSH	HL
AB10: 7E                        	LD	A,(HL)		;set drive code in default fcb.
AB11: 32 CD AB                  	LD	(FCB),A
AB14: 3E 10                     	LD	A,16		;put second name 16 bytes later.
AB16: CD 60 A6                  	CALL	CONVERT		;convert second file name.
AB19: E1                        	POP	HL
AB1A: 7E                        	LD	A,(HL)		;and set the drive for this second file.
AB1B: 32 DD AB                  	LD	(FCB+16),A
AB1E: AF                        	XOR	A		;clear record byte in fcb.
AB1F: 32 ED AB                  	LD	(FCB+32),A
AB22: 11 5C 00                  	LD	DE,TFCB		;move it into place at(005Ch).
AB25: 21 CD AB                  	LD	HL,FCB
AB28: 06 21                     	LD	B,33
AB2A: CD 42 A8                  	CALL	HL2DE
AB2D: 21 08 A4                  	LD	HL,INBUFF+2	;now move the remainder of the input
AB30: 7E                        UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
AB31: B7                        	OR	A		;or a null.
AB32: CA 3E AB                  	JP	Z,UNKWN6
AB35: FE 20                     	CP	' '
AB37: CA 3E AB                  	JP	Z,UNKWN6
AB3A: 23                        	INC	HL
AB3B: C3 30 AB                  	JP	UNKWN5
                                ;
                                ;   Do the line move now. It ends in a null byte.
                                ;
AB3E: 06 00                     UNKWN6:	LD	B,0		;keep a character count.
AB40: 11 81 00                  	LD	DE,TBUFF+1	;data gets put here.
AB43: 7E                        UNKWN7:	LD	A,(HL)		;move it now.
AB44: 12                        	LD	(DE),A
AB45: B7                        	OR	A
AB46: CA 4F AB                  	JP	Z,UNKWN8
AB49: 04                        	INC	B
AB4A: 23                        	INC	HL
AB4B: 13                        	INC	DE
AB4C: C3 43 AB                  	JP	UNKWN7
AB4F: 78                        UNKWN8:	LD	A,B		;now store the character count.
AB50: 32 80 00                  	LD	(TBUFF),A
AB53: CD 98 A4                  	CALL	CRLF		;clean up the screen.
AB56: CD D5 A5                  	CALL	STDDMA		;set standard transfer address.
AB59: CD 1A A5                  	CALL	SETCDRV		;reset current drive.
AB5C: CD 00 01                  	CALL	TBASE		;and execute the program.
                                ;
                                ;   Transiant programs return here (or reboot).
                                ;
AB5F: 31 AB AB                  	LD	SP,BATCH	;set stack first off.
AB62: CD 29 A5                  	CALL	MOVECD		;move current drive into place (TDRIVE).
AB65: CD BD A4                  	CALL	DSKSEL		;and reselect it.
AB68: C3 82 A7                  	JP	CMMND1		;back to comand mode.
                                ;
                                ;   Get here if some error occured.
                                ;
AB6B: CD 66 A8                  UNKWN9:	CALL	RESETDR		;inproper format.
AB6E: C3 09 A6                  	JP	SYNERR
AB71: 01 7A AB                  UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
AB74: CD A7 A4                  	CALL	PLINE
AB77: C3 86 AB                  	JP	GETBACK
AB7A: 42 61 64 20 6C 6F 61 64   BADLOAD:DB	'Bad load',0
AB82: 00 
AB83: 43 4F 4D                  COMFILE:DB	'COM'		;command file extension.
                                ;
                                ;   Get here to return to command level. We will reset the
                                ; previous active drive and then either return to command
                                ; level directly or print error message and then return.
                                ;
AB86: CD 66 A8                  GETBACK:CALL	RESETDR		;reset previous drive.
AB89: CD 5E A6                  GETBACK1: CALL	CONVFST		;convert first name in (FCB).
AB8C: 3A CE AB                  	LD	A,(FCB+1)	;if this was just a drive change request,
AB8F: D6 20                     	SUB	' '		;make sure it was valid.
AB91: 21 F0 AB                  	LD	HL,CHGDRV
AB94: B6                        	OR	(HL)
AB95: C2 09 A6                  	JP	NZ,SYNERR
AB98: C3 82 A7                  	JP	CMMND1		;ok, return to command level.
                                ;
                                ;   ccp stack area.
                                ;
AB9B: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ABA3: 00 00 00 00 00 00 00 00 
                                CCPSTACK EQU	$	;end of ccp stack area.
                                ;
                                ;   Batch (or SUBMIT) processing information storage.
                                ;
ABAB: 00                        BATCH:	DB	0		;batch mode flag (0=not active).
ABAC: 00 24 24 24 20 20 20 20   BATCHFCB: DB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
ABB4: 20 53 55 42 00 00 00 00 
ABBC: 00 00 00 00 00 00 00 00 
ABC4: 00 00 00 00 00 00 00 00 
ABCC: 00 
                                ;
                                ;   File control block setup by the CCP.
                                ;
ABCD: 00 20 20 20 20 20 20 20   FCB:	DB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
ABD5: 20 20 20 20 00 00 00 00 
ABDD: 00 20 20 20 20 20 20 20 
ABE5: 20 20 20 20 00 00 00 00 
ABED: 00 
ABEE: 00                        RTNCODE:DB	0		;status returned from bdos call.
ABEF: 00                        CDRIVE:	DB	0		;currently active drive.
ABF0: 00                        CHGDRV:	DB	0		;change in drives flag (0=no change).
ABF1: 00 00                     NBYTES:	DW	0		;byte counter used by TYPE.
                                ;
                                ;   Room for expansion?
                                ;
ABF3: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0
ABFB: 00 00 00 00 00 
                                ;
                                ;   Note that the following six bytes must match those at
                                ; (PATTRN1) or cp/m will XALT. Why?
                                ;
AC00: 00 16 00 00 00 00         PATTRN2:DB	0,22,0,0,0,0	;(* serial number bytes *).
                                ;
                                ;**************************************************************
                                ;*
                                ;*                    B D O S   E N T R Y
                                ;*
                                ;**************************************************************
                                ;
AC06: C3 11 AC                  FBASE:	JP	FBASE1
                                ;
                                ;   Bdos error table.
                                ;
AC09: 99 AC                     BADSCTR:DW	ERROR1		;bad sector on read or write.
AC0B: A5 AC                     BADSLCT:DW	ERROR2		;bad disk select.
AC0D: AB AC                     RODISK:	DW	ERROR3		;disk is read only.
AC0F: B1 AC                     ROFILE:	DW	ERROR4		;file is read only.
                                ;
                                ;   Entry into bdos. (DE) or (E) are the parameters passed. The
                                ; function number desired is in register (C).
                                ;
AC11: EB                        FBASE1:	EX	DE,HL		;save the (DE) parameters.
AC12: 22 43 AF                  	LD	(PARAMS),HL
AC15: EB                        	EX	DE,HL
AC16: 7B                        	LD	A,E		;and save register (E) in particular.
AC17: 32 D6 B9                  	LD	(EPARAM),A
AC1A: 21 00 00                  	LD	HL,0
AC1D: 22 45 AF                  	LD	(STATUS),HL	;clear return status.
AC20: 39                        	ADD	HL,SP
AC21: 22 0F AF                  	LD	(USRSTACK),HL	;save users stack pointer.
AC24: 31 41 AF                  	LD	SP,STKAREA	;and set our own.
AC27: AF                        	XOR	A		;clear auto select storage space.
AC28: 32 E0 B9                  	LD	(AUTOFLAG),A
AC2B: 32 DE B9                  	LD	(AUTO),A
AC2E: 21 74 B9                  	LD	HL,GOBACK	;set return address.
AC31: E5                        	PUSH	HL
AC32: 79                        	LD	A,C		;get function number.
AC33: FE 29                     	CP	NFUNCTS		;valid function number?
AC35: D0                        	RET	NC
AC36: 4B                        	LD	C,E		;keep single register function here.
AC37: 21 47 AC                  	LD	HL,FUNCTNS	;now look thru the function table.
AC3A: 5F                        	LD	E,A
AC3B: 16 00                     	LD	D,0		;(DE)=function number.
AC3D: 19                        	ADD	HL,DE
AC3E: 19                        	ADD	HL,DE		;(HL)=(start of table)+2*(function number).
AC3F: 5E                        	LD	E,(HL)
AC40: 23                        	INC	HL
AC41: 56                        	LD	D,(HL)		;now (DE)=address for this function.
AC42: 2A 43 AF                  	LD	HL,(PARAMS)	;retrieve parameters.
AC45: EB                        	EX	DE,HL		;now (DE) has the original parameters.
AC46: E9                        	JP	(HL)		;execute desired function.
                                ;
                                ;   BDOS function jump table.
                                ;
                                NFUNCTS EQU	41		;number of functions in followin table.
                                ;
AC47: D1 BA C8 AE 90 AD CE AE   FUNCTNS:DW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
AC4F: 12 BA 03 BC D4 AE ED AE 
AC57: F3 AE F8 AE E1 AD FE AE   	DW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
AC5F: 7E B8 83 B8 45 B8 9C B8 
AC67: A5 B8 AB B8 C8 B8 D7 B8   	DW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
AC6F: E0 B8 E6 B8 EC B8 
AC75: F5 B8 FE B8 04 B9 0A B9   	DW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
AC7D: 11 B9 2C B1 17 B9 1D B9 
AC85: 26 B9 2D B9 41 B9 47 B9   	DW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
AC8D: 4D B9 0E B8 53 B9 04 AF 
AC95: 04 AF 9B B9               	DW	RTN,WTSPECL
                                ;
                                ;   Bdos error message section.
                                ;
AC99: 21 CA AC                  ERROR1:	LD	HL,BADSEC	;bad sector message.
AC9C: CD E5 AC                  	CALL	PRTERR		;print it and get a 1 char responce.
AC9F: FE 03                     	CP	CNTRLC		;re-boot request (control-c)?
ACA1: CA 00 00                  	JP	Z,0		;yes.
ACA4: C9                        	RET			;no, return to retry i/o function.
                                ;
ACA5: 21 D5 AC                  ERROR2:	LD	HL,BADSEL	;bad drive selected.
ACA8: C3 B4 AC                  	JP	ERROR5
                                ;
ACAB: 21 E1 AC                  ERROR3:	LD	HL,DISKRO	;disk is read only.
ACAE: C3 B4 AC                  	JP	ERROR5
                                ;
ACB1: 21 DC AC                  ERROR4:	LD	HL,FILERO	;file is read only.
                                ;
ACB4: CD E5 AC                  ERROR5:	CALL	PRTERR
ACB7: C3 00 00                  	JP	0		;always reboot on these errors.
                                ;
ACBA: 42 64 6F 73 20 45 72 72   BDOSERR:DB	'Bdos Err On '
ACC2: 20 4F 6E 20 
ACC6: 20 3A 20 24               BDOSDRV:DB	' : $'
ACCA: 42 61 64 20 53 65 63 74   BADSEC:	DB	'Bad Sector$'
ACD2: 6F 72 24 
ACD5: 53 65 6C 65 63 74 24      BADSEL:	DB	'Select$'
ACDC: 46 69 6C 65 20            FILERO:	DB	'File '
ACE1: 52 2F 4F 24               DISKRO:	DB	'R/O$'
                                ;
                                ;   Print bdos error message.
                                ;
ACE5: E5                        PRTERR:	PUSH	HL		;save second message pointer.
ACE6: CD C9 AD                  	CALL	OUTCRLF		;send (cr)(lf).
ACE9: 3A 42 AF                  	LD	A,(ACTIVE)	;get active drive.
ACEC: C6 41                     	ADD	A,'A'		;make ascii.
ACEE: 32 C6 AC                  	LD	(BDOSDRV),A	;and put in message.
ACF1: 01 BA AC                  	LD	BC,BDOSERR	;and print it.
ACF4: CD D3 AD                  	CALL	PRTMESG
ACF7: C1                        	POP	BC		;print second message line now.
ACF8: CD D3 AD                  	CALL	PRTMESG
                                ;
                                ;   Get an input character. We will check our 1 character
                                ; buffer first. This may be set by the console status routine.
                                ;
ACFB: 21 0E AF                  GETCHAR:LD	HL,CHARBUF	;check character buffer.
ACFE: 7E                        	LD	A,(HL)		;anything present already?
ACFF: 36 00                     	LD	(HL),0		;...either case clear it.
AD01: B7                        	OR	A
AD02: C0                        	RET	NZ		;yes, use it.
AD03: C3 59 BD                  	JP	CONIN		;nope, go get a character responce.
                                ;
                                ;   Input and echo a character.
                                ;
AD06: CD FB AC                  GETECHO:CALL	GETCHAR		;input a character.
AD09: CD 14 AD                  	CALL	CHKCHAR		;carriage control?
AD0C: D8                        	RET	C		;no, a regular control char so don't echo.
AD0D: F5                        	PUSH	AF		;ok, save character now.
AD0E: 4F                        	LD	C,A
AD0F: CD 90 AD                  	CALL	OUTCON		;and echo it.
AD12: F1                        	POP	AF		;get character and return.
AD13: C9                        	RET	
                                ;
                                ;   Check character in (A). Set the zero flag on a carriage
                                ; control character and the carry flag on any other control
                                ; character.
                                ;
AD14: FE 0D                     CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
AD16: C8                        	RET	Z		;or a tab.
AD17: FE 0A                     	CP	LF
AD19: C8                        	RET	Z
AD1A: FE 09                     	CP	TAB
AD1C: C8                        	RET	Z
AD1D: FE 08                     	CP	BS
AD1F: C8                        	RET	Z
AD20: FE 20                     	CP	' '		;other control char? Set carry flag.
AD22: C9                        	RET	
                                ;
                                ;   Check the console during output. XALT on a control-s, then
                                ; reboot on a control-c. If anything else is ready, clear the
                                ; zero flag and return (the calling routine may want to do
                                ; something).
                                ;
AD23: 3A 0E AF                  CKCONSOL: LD	A,(CHARBUF)	;check buffer.
AD26: B7                        	OR	A		;if anything, just return without checking.
AD27: C2 45 AD                  	JP	NZ,CKCON2
AD2A: CD 7B BB                  	CALL	CONST		;nothing in buffer. Check console.
AD2D: E6 01                     	AND	01H		;look at bit 0.
AD2F: C8                        	RET	Z		;return if nothing.
AD30: CD 59 BD                  	CALL	CONIN		;ok, get it.
AD33: FE 13                     	CP	CNTRLS		;if not control-s, return with zero cleared.
AD35: C2 42 AD                  	JP	NZ,CKCON1
AD38: CD 59 BD                  	CALL	CONIN		;XALT processing until another char
AD3B: FE 03                     	CP	CNTRLC		;is typed. Control-c?
AD3D: CA 00 00                  	JP	Z,0		;yes, reboot now.
AD40: AF                        	XOR	A		;no, just pretend nothing was ever ready.
AD41: C9                        	RET	
AD42: 32 0E AF                  CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
AD45: 3E 01                     CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
AD47: C9                        	RET	
                                ;
                                ;   Output (C) to the screen. If the printer flip-flop flag
                                ; is set, we will send character to printer also. The console
                                ; will be checked in the process.
                                ;
AD48: 3A 0A AF                  OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
AD4B: B7                        	OR	A		;anything and we won't generate output.
AD4C: C2 62 AD                  	JP	NZ,OUTCHR1
AD4F: C5                        	PUSH	BC
AD50: CD 23 AD                  	CALL	CKCONSOL	;check console (we don't care whats there).
AD53: C1                        	POP	BC
AD54: C5                        	PUSH	BC
AD55: CD DE BB                  	CALL	CONOUT		;output (C) to the screen.
AD58: C1                        	POP	BC
AD59: C5                        	PUSH	BC
AD5A: 3A 0D AF                  	LD	A,(PRTFLAG)	;check printer flip-flop flag.
AD5D: B7                        	OR	A
AD5E: C4 03 BC                  	CALL	NZ,LIST		;print it also if non-zero.
AD61: C1                        	POP	BC
AD62: 79                        OUTCHR1:LD	A,C		;update cursors position.
AD63: 21 0C AF                  	LD	HL,CURPOS
AD66: FE 7F                     	CP	DEL		;rubouts don't do anything here.
AD68: C8                        	RET	Z
AD69: 34                        	INC	(HL)		;bump line pointer.
AD6A: FE 20                     	CP	' '		;and return if a normal character.
AD6C: D0                        	RET	NC
AD6D: 35                        	DEC	(HL)		;restore and check for the start of the line.
AD6E: 7E                        	LD	A,(HL)
AD6F: B7                        	OR	A
AD70: C8                        	RET	Z		;ingnore control characters at the start of the line.
AD71: 79                        	LD	A,C
AD72: FE 08                     	CP	BS		;is it a backspace?
AD74: C2 79 AD                  	JP	NZ,OUTCHR2
AD77: 35                        	DEC	(HL)		;yes, backup pointer.
AD78: C9                        	RET	
AD79: FE 0A                     OUTCHR2:CP	LF		;is it a line feed?
AD7B: C0                        	RET	NZ		;ignore anything else.
AD7C: 36 00                     	LD	(HL),0		;reset pointer to start of line.
AD7E: C9                        	RET	
                                ;
                                ;   Output (A) to the screen. If it is a control character
                                ; (other than carriage control), use ^x format.
                                ;
AD7F: 79                        SHOWIT:	LD	A,C
AD80: CD 14 AD                  	CALL	CHKCHAR		;check character.
AD83: D2 90 AD                  	JP	NC,OUTCON	;not a control, use normal output.
AD86: F5                        	PUSH	AF
AD87: 0E 5E                     	LD	C,'^'		;for a control character, preceed it with '^'.
AD89: CD 48 AD                  	CALL	OUTCHAR
AD8C: F1                        	POP	AF
AD8D: F6 40                     	OR	'@'		;and then use the letter equivelant.
AD8F: 4F                        	LD	C,A
                                ;
                                ;   Function to output (C) to the console device and expand tabs
                                ; if necessary.
                                ;
AD90: 79                        OUTCON:	LD	A,C
AD91: FE 09                     	CP	TAB		;is it a tab?
AD93: C2 48 AD                  	JP	NZ,OUTCHAR	;use regular output.
AD96: 0E 20                     OUTCON1:LD	C,' '		;yes it is, use spaces instead.
AD98: CD 48 AD                  	CALL	OUTCHAR
AD9B: 3A 0C AF                  	LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
                                
AD9E: E6 07                     	AND	07H		;position.
ADA0: C2 96 AD                  	JP	NZ,OUTCON1
ADA3: C9                        	RET	
                                ;
                                ;   Echo a backspace character. Erase the prevoius character
                                ; on the screen.
                                ;
ADA4: CD AC AD                  BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
ADA7: 0E 20                     	LD	C,' '		;then blank that character.
ADA9: CD DE BB                  	CALL	CONOUT
ADAC: 0E 08                     BACKUP1:LD	C,BS		;then back space once more.
ADAE: C3 DE BB                  	JP	CONOUT
                                ;
                                ;   Signal a deleted line. Print a '#' at the end and start
                                ; over.
                                ;
ADB1: 0E 23                     NEWLINE:LD	C,'#'
ADB3: CD 48 AD                  	CALL	OUTCHAR		;print this.
ADB6: CD C9 AD                  	CALL	OUTCRLF		;start new line.
ADB9: 3A 0C AF                  NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
ADBC: 21 0B AF                  	LD	HL,STARTING
ADBF: BE                        	CP	(HL)
ADC0: D0                        	RET	NC		;there yet?
ADC1: 0E 20                     	LD	C,' '
ADC3: CD 48 AD                  	CALL	OUTCHAR		;nope, keep going.
ADC6: C3 B9 AD                  	JP	NEWLN1
                                ;
                                ;   Output a (cr) (lf) to the console device (screen).
                                ;
ADC9: 0E 0D                     OUTCRLF:LD	C,CR
ADCB: CD 48 AD                  	CALL	OUTCHAR
ADCE: 0E 0A                     	LD	C,LF
ADD0: C3 48 AD                  	JP	OUTCHAR
                                ;
                                ;   Print message pointed to by (BC). It will end with a '$'.
                                ;
ADD3: 0A                        PRTMESG:LD	A,(BC)		;check for terminating character.
ADD4: FE 24                     	CP	'$'
ADD6: C8                        	RET	Z
ADD7: 03                        	INC	BC
ADD8: C5                        	PUSH	BC		;otherwise, bump pointer and print it.
ADD9: 4F                        	LD	C,A
ADDA: CD 90 AD                  	CALL	OUTCON
ADDD: C1                        	POP	BC
ADDE: C3 D3 AD                  	JP	PRTMESG
                                ;
                                ;   Function to execute a buffered read.
                                ;
ADE1: 3A 0C AF                  RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
ADE4: 32 0B AF                  	LD	(STARTING),A
ADE7: 2A 43 AF                  	LD	HL,(PARAMS)	;get the maximum buffer space.
ADEA: 4E                        	LD	C,(HL)
ADEB: 23                        	INC	HL		;point to first available space.
ADEC: E5                        	PUSH	HL		;and save.
ADED: 06 00                     	LD	B,0		;keep a character count.
ADEF: C5                        RDBUF1:	PUSH	BC
ADF0: E5                        	PUSH	HL
ADF1: CD FB AC                  RDBUF2:	CALL	GETCHAR		;get the next input character.
ADF4: E6 7F                     	AND	7FH		;strip bit 7.
ADF6: E1                        	POP	HL		;reset registers.
ADF7: C1                        	POP	BC
ADF8: FE 0D                     	CP	CR		;en of the line?
ADFA: CA C1 AE                  	JP	Z,RDBUF17
ADFD: FE 0A                     	CP	LF
ADFF: CA C1 AE                  	JP	Z,RDBUF17
AE02: FE 08                     	CP	BS		;how about a backspace?
AE04: C2 16 AE                  	JP	NZ,RDBUF3
AE07: 78                        	LD	A,B		;yes, but ignore at the beginning of the line.
AE08: B7                        	OR	A
AE09: CA EF AD                  	JP	Z,RDBUF1
AE0C: 05                        	DEC	B		;ok, update counter.
AE0D: 3A 0C AF                  	LD	A,(CURPOS)	;if we backspace to the start of the line,
AE10: 32 0A AF                  	LD	(OUTFLAG),A	;treat as a cancel (control-x).
AE13: C3 70 AE                  	JP	RDBUF10
AE16: FE 7F                     RDBUF3:	CP	DEL		;user typed a rubout?
AE18: C2 26 AE                  	JP	NZ,RDBUF4
AE1B: 78                        	LD	A,B		;ignore at the start of the line.
AE1C: B7                        	OR	A
AE1D: CA EF AD                  	JP	Z,RDBUF1
AE20: 7E                        	LD	A,(HL)		;ok, echo the prevoius character.
AE21: 05                        	DEC	B		;and reset pointers (counters).
AE22: 2B                        	DEC	HL
AE23: C3 A9 AE                  	JP	RDBUF15
AE26: FE 05                     RDBUF4:	CP	CNTRLE		;physical end of line?
AE28: C2 37 AE                  	JP	NZ,RDBUF5
AE2B: C5                        	PUSH	BC		;yes, do it.
AE2C: E5                        	PUSH	HL
AE2D: CD C9 AD                  	CALL	OUTCRLF
AE30: AF                        	XOR	A		;and update starting position.
AE31: 32 0B AF                  	LD	(STARTING),A
AE34: C3 F1 AD                  	JP	RDBUF2
AE37: FE 10                     RDBUF5:	CP	CNTRLP		;control-p?
AE39: C2 48 AE                  	JP	NZ,RDBUF6
AE3C: E5                        	PUSH	HL		;yes, flip the print flag filp-flop byte.
AE3D: 21 0D AF                  	LD	HL,PRTFLAG
AE40: 3E 01                     	LD	A,1		;PRTFLAG=1-PRTFLAG
AE42: 96                        	SUB	(HL)
AE43: 77                        	LD	(HL),A
AE44: E1                        	POP	HL
AE45: C3 EF AD                  	JP	RDBUF1
AE48: FE 18                     RDBUF6:	CP	CNTRLX		;control-x (cancel)?
AE4A: C2 5F AE                  	JP	NZ,RDBUF8
AE4D: E1                        	POP	HL
AE4E: 3A 0B AF                  RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
AE51: 21 0C AF                  	LD	HL,CURPOS
AE54: BE                        	CP	(HL)
AE55: D2 E1 AD                  	JP	NC,RDBUFF	;done yet?
AE58: 35                        	DEC	(HL)		;no, decrement pointer and output back up one space.
AE59: CD A4 AD                  	CALL	BACKUP
AE5C: C3 4E AE                  	JP	RDBUF7
AE5F: FE 15                     RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
AE61: C2 6B AE                  	JP	NZ,RDBUF9
AE64: CD B1 AD                  	CALL	NEWLINE		;start a new line.
AE67: E1                        	POP	HL
AE68: C3 E1 AD                  	JP	RDBUFF
AE6B: FE 12                     RDBUF9:	CP	CNTRLR		;control-r?
AE6D: C2 A6 AE                  	JP	NZ,RDBUF14
AE70: C5                        RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
AE71: CD B1 AD                  	CALL	NEWLINE
AE74: C1                        	POP	BC
AE75: E1                        	POP	HL
AE76: E5                        	PUSH	HL
AE77: C5                        	PUSH	BC
AE78: 78                        RDBUF11:LD	A,B		;done whole line yet?
AE79: B7                        	OR	A
AE7A: CA 8A AE                  	JP	Z,RDBUF12
AE7D: 23                        	INC	HL		;nope, get next character.
AE7E: 4E                        	LD	C,(HL)
AE7F: 05                        	DEC	B		;count it.
AE80: C5                        	PUSH	BC
AE81: E5                        	PUSH	HL
AE82: CD 7F AD                  	CALL	SHOWIT		;and display it.
AE85: E1                        	POP	HL
AE86: C1                        	POP	BC
AE87: C3 78 AE                  	JP	RDBUF11
AE8A: E5                        RDBUF12:PUSH	HL		;done with line. If we were displaying
AE8B: 3A 0A AF                  	LD	A,(OUTFLAG)	;then update cursor position.
AE8E: B7                        	OR	A
AE8F: CA F1 AD                  	JP	Z,RDBUF2
AE92: 21 0C AF                  	LD	HL,CURPOS	;because this line is shorter, we must
AE95: 96                        	SUB	(HL)		;back up the cursor (not the screen however)
AE96: 32 0A AF                  	LD	(OUTFLAG),A	;some number of positions.
AE99: CD A4 AD                  RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
AE9C: 21 0A AF                  	LD	HL,OUTFLAG	;zero, the screen will not be changed.
AE9F: 35                        	DEC	(HL)
AEA0: C2 99 AE                  	JP	NZ,RDBUF13
AEA3: C3 F1 AD                  	JP	RDBUF2		;now just get the next character.
                                ;
                                ;   Just a normal character, put this in our buffer and echo.
                                ;
AEA6: 23                        RDBUF14:INC	HL
AEA7: 77                        	LD	(HL),A		;store character.
AEA8: 04                        	INC	B		;and count it.
AEA9: C5                        RDBUF15:PUSH	BC
AEAA: E5                        	PUSH	HL
AEAB: 4F                        	LD	C,A		;echo it now.
AEAC: CD 7F AD                  	CALL	SHOWIT
AEAF: E1                        	POP	HL
AEB0: C1                        	POP	BC
AEB1: 7E                        	LD	A,(HL)		;was it an abort request?
AEB2: FE 03                     	CP	CNTRLC		;control-c abort?
AEB4: 78                        	LD	A,B
AEB5: C2 BD AE                  	JP	NZ,RDBUF16
AEB8: FE 01                     	CP	1		;only if at start of line.
AEBA: CA 00 00                  	JP	Z,0
AEBD: B9                        RDBUF16:CP	C		;nope, have we filled the buffer?
AEBE: DA EF AD                  	JP	C,RDBUF1
AEC1: E1                        RDBUF17:POP	HL		;yes end the line and return.
AEC2: 70                        	LD	(HL),B
AEC3: 0E 0D                     	LD	C,CR
AEC5: C3 48 AD                  	JP	OUTCHAR		;output (cr) and return.
                                ;
                                ;   Function to get a character from the console device.
                                ;
AEC8: CD 06 AD                  GETCON:	CALL	GETECHO		;get and echo.
AECB: C3 01 AF                  	JP	SETSTAT		;save status and return.
                                ;
                                ;   Function to get a character from the tape reader device.
                                ;
AECE: CD C8 BB                  GETRDR:	CALL	READER		;get a character from reader, set status and return.
AED1: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;  Function to perform direct console i/o. If (C) contains (FF)
                                ; then this is an input request. If (C) contains (FE) then
                                ; this is a status request. Otherwise we are to output (C).
                                ;
AED4: 79                        DIRCIO:	LD	A,C		;test for (FF).
AED5: 3C                        	INC	A
AED6: CA E0 AE                  	JP	Z,DIRC1
AED9: 3C                        	INC	A		;test for (FE).
AEDA: CA 7B BB                  	JP	Z,CONST
AEDD: C3 DE BB                  	JP	CONOUT		;just output (C).
AEE0: CD 7B BB                  DIRC1:	CALL	CONST		;this is an input request.
AEE3: B7                        	OR	A
AEE4: CA 91 B9                  	JP	Z,GOBACK1	;not ready? Just return (directly).
AEE7: CD 59 BD                  	CALL	CONIN		;yes, get character.
AEEA: C3 01 AF                  	JP	SETSTAT		;set status and return.
                                ;
                                ;   Function to return the i/o byte.
                                ;
AEED: 3A 03 00                  GETIOB:	LD	A,(IOBYTE)
AEF0: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;   Function to set the i/o byte.
                                ;
AEF3: 21 03 00                  SETIOB:	LD	HL,IOBYTE
AEF6: 71                        	LD	(HL),C
AEF7: C9                        	RET	
                                ;
                                ;   Function to print the character string pointed to by (DE)
                                ; on the console device. The string ends with a '$'.
                                ;
AEF8: EB                        PRTSTR:	EX	DE,HL
AEF9: 4D                        	LD	C,L
AEFA: 44                        	LD	B,H		;now (BC) points to it.
AEFB: C3 D3 AD                  	JP	PRTMESG
                                ;
                                ;   Function to interigate the console device.
                                ;
AEFE: CD 23 AD                  GETCSTS:CALL	CKCONSOL
                                ;
                                ;   Get here to set the status and return to the cleanup
                                ; section. Then back to the user.
                                ;
AF01: 32 45 AF                  SETSTAT:LD	(STATUS),A
AF04: C9                        RTN:	RET	
                                ;
                                ;   Set the status to 1 (read or write error code).
                                ;
AF05: 3E 01                     IOERR1:	LD	A,1
AF07: C3 01 AF                  	JP	SETSTAT
                                ;
AF0A: 00                        OUTFLAG:DB	0		;output flag (non zero means no output).
AF0B: 02                        STARTING: DB	2		;starting position for cursor.
AF0C: 00                        CURPOS:	DB	0		;cursor position (0=start of line).
AF0D: 00                        PRTFLAG:DB	0		;printer flag (control-p toggle). List if non zero.
AF0E: 00                        CHARBUF:DB	0		;single input character buffer.
                                ;
                                ;   Stack area for BDOS calls.
                                ;
AF0F: 00 00                     USRSTACK: DW	0		;save users stack pointer here.
                                ;
AF11: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
AF19: 00 00 00 00 00 00 00 00 
AF21: 00 00 00 00 00 00 00 00 
AF29: 00 00 00 00 00 00 00 00   	DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
AF31: 00 00 00 00 00 00 00 00 
AF39: 00 00 00 00 00 00 00 00 
                                STKAREA EQU	$		;end of stack area.
                                ;
AF41: 00                        USERNO:	DB	0		;current user number.
AF42: 00                        ACTIVE:	DB	0		;currently active drive.
AF43: 00 00                     PARAMS:	DW	0		;save (DE) parameters here on entry.
AF45: 00 00                     STATUS:	DW	0		;status returned from bdos function.
                                ;
                                ;   Select error occured, jump to error routine.
                                ;
AF47: 21 0B AC                  SLCTERR:LD	HL,BADSLCT
                                ;
                                ;   Jump to (HL) indirectly.
                                ;
AF4A: 5E                        JUMPHL:	LD	E,(HL)
AF4B: 23                        	INC	HL
AF4C: 56                        	LD	D,(HL)		;now (DE) contain the desired address.
AF4D: EB                        	EX	DE,HL
AF4E: E9                        	JP	(HL)
                                ;
                                ;   Block move. (DE) to (HL), (C) bytes total.
                                ;
AF4F: 0C                        DE2HL:	INC	C		;is count down to zero?
AF50: 0D                        DE2HL1:	DEC	C
AF51: C8                        	RET	Z		;yes, we are done.
AF52: 1A                        	LD	A,(DE)		;no, move one more byte.
AF53: 77                        	LD	(HL),A
AF54: 13                        	INC	DE
AF55: 23                        	INC	HL
AF56: C3 50 AF                  	JP	DE2HL1		;and repeat.
                                ;
                                ;   Select the desired drive.
                                ;
AF59: 3A 42 AF                  SELECT:	LD	A,(ACTIVE)	;get active disk.
AF5C: 4F                        	LD	C,A
AF5D: CD 26 BC                  	CALL	SELDSK		;select it.
AF60: 7C                        	LD	A,H		;valid drive?
AF61: B5                        	OR	L		;valid drive?
AF62: C8                        	RET	Z		;return if not.
                                ;
                                ;   Here, the BIOS returned the address of the parameter block
                                ; in (HL). We will extract the necessary pointers and save them.
                                ;
AF63: 5E                        	LD	E,(HL)		;yes, get address of translation table into (DE).
AF64: 23                        	INC	HL
AF65: 56                        	LD	D,(HL)
AF66: 23                        	INC	HL
AF67: 22 B3 B9                  	LD	(SCRATCH1),HL	;save pointers to scratch areas.
AF6A: 23                        	INC	HL
AF6B: 23                        	INC	HL
AF6C: 22 B5 B9                  	LD	(SCRATCH2),HL	;ditto.
AF6F: 23                        	INC	HL
AF70: 23                        	INC	HL
AF71: 22 B7 B9                  	LD	(SCRATCH3),HL	;ditto.
AF74: 23                        	INC	HL
AF75: 23                        	INC	HL
AF76: EB                        	EX	DE,HL		;now save the translation table address.
AF77: 22 D0 B9                  	LD	(XLATE),HL
AF7A: 21 B9 B9                  	LD	HL,DIRBUF	;put the next 8 bytes here.
AF7D: 0E 08                     	LD	C,8		;they consist of the directory buffer
AF7F: CD 4F AF                  	CALL	DE2HL		;pointer, parameter block pointer,
AF82: 2A BB B9                  	LD	HL,(DISKPB)	;check and allocation vectors.
AF85: EB                        	EX	DE,HL
AF86: 21 C1 B9                  	LD	HL,SECTORS	;move parameter block into our ram.
AF89: 0E 0F                     	LD	C,15		;it is 15 bytes long.
AF8B: CD 4F AF                  	CALL	DE2HL
AF8E: 2A C6 B9                  	LD	HL,(DSKSIZE)	;check disk size.
AF91: 7C                        	LD	A,H		;more than 256 blocks on this?
AF92: 21 DD B9                  	LD	HL,BIGDISK
AF95: 36 FF                     	LD	(HL),0FFH	;set to samll.
AF97: B7                        	OR	A
AF98: CA 9D AF                  	JP	Z,SELECT1
AF9B: 36 00                     	LD	(HL),0		;wrong, set to large.
AF9D: 3E FF                     SELECT1:LD	A,0FFH		;clear the zero flag.
AF9F: B7                        	OR	A
AFA0: C9                        	RET	
                                ;
                                ;   Routine to home the disk track head and clear pointers.
                                ;
AFA1: CD 1D BC                  HOMEDRV:CALL	HOME		;home the head.
AFA4: AF                        	XOR	A
AFA5: 2A B5 B9                  	LD	HL,(SCRATCH2)	;set our track pointer also.
AFA8: 77                        	LD	(HL),A
AFA9: 23                        	INC	HL
AFAA: 77                        	LD	(HL),A
AFAB: 2A B7 B9                  	LD	HL,(SCRATCH3)	;and our sector pointer.
AFAE: 77                        	LD	(HL),A
AFAF: 23                        	INC	HL
AFB0: 77                        	LD	(HL),A
AFB1: C9                        	RET	
                                ;
                                ;   Do the actual disk read and check the error return status.
                                ;
AFB2: CD 54 BC                  DOREAD:	CALL	READ
AFB5: C3 BB AF                  	JP	IORET
                                ;
                                ;   Do the actual disk write and handle any bios error.
                                ;
AFB8: CD 63 BC                  DOWRITE:CALL	WRITE
AFBB: B7                        IORET:	OR	A
AFBC: C8                        	RET	Z		;return unless an error occured.
AFBD: 21 09 AC                  	LD	HL,BADSCTR	;bad read/write on this sector.
AFC0: C3 4A AF                  	JP	JUMPHL
                                ;
                                ;   Routine to select the track and sector that the desired
                                ; block number falls in.
                                ;
AFC3: 2A EA B9                  TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
AFC6: 0E 02                     	LD	C,2		;in directory and compute sector #.
AFC8: CD EA B0                  	CALL	SHIFTR		;sector #=file-position/4.
AFCB: 22 E5 B9                  	LD	(BLKNMBR),HL	;save this as the block number of interest.
AFCE: 22 EC B9                  	LD	(CKSUMTBL),HL	;what's it doing here too?
                                ;
                                ;   if the sector number has already been set (BLKNMBR), enter
                                ; at this point.
                                ;
AFD1: 21 E5 B9                  TRKSEC1:LD	HL,BLKNMBR
AFD4: 4E                        	LD	C,(HL)		;move sector number into (BC).
AFD5: 23                        	INC	HL
AFD6: 46                        	LD	B,(HL)
AFD7: 2A B7 B9                  	LD	HL,(SCRATCH3)	;get current sector number and
AFDA: 5E                        	LD	E,(HL)		;move this into (DE).
AFDB: 23                        	INC	HL
AFDC: 56                        	LD	D,(HL)
AFDD: 2A B5 B9                  	LD	HL,(SCRATCH2)	;get current track number.
AFE0: 7E                        	LD	A,(HL)		;and this into (HL).
AFE1: 23                        	INC	HL
AFE2: 66                        	LD	H,(HL)
AFE3: 6F                        	LD	L,A
AFE4: 79                        TRKSEC2:LD	A,C		;is desired sector before current one?
AFE5: 93                        	SUB	E
AFE6: 78                        	LD	A,B
AFE7: 9A                        	SBC	A,D
AFE8: D2 FA AF                  	JP	NC,TRKSEC3
AFEB: E5                        	PUSH	HL		;yes, decrement sectors by one track.
AFEC: 2A C1 B9                  	LD	HL,(SECTORS)	;get sectors per track.
AFEF: 7B                        	LD	A,E
AFF0: 95                        	SUB	L
AFF1: 5F                        	LD	E,A
AFF2: 7A                        	LD	A,D
AFF3: 9C                        	SBC	A,H
AFF4: 57                        	LD	D,A		;now we have backed up one full track.
AFF5: E1                        	POP	HL
AFF6: 2B                        	DEC	HL		;adjust track counter.
AFF7: C3 E4 AF                  	JP	TRKSEC2
AFFA: E5                        TRKSEC3:PUSH	HL		;desired sector is after current one.
AFFB: 2A C1 B9                  	LD	HL,(SECTORS)	;get sectors per track.
AFFE: 19                        	ADD	HL,DE		;bump sector pointer to next track.
AFFF: DA 0F B0                  	JP	C,TRKSEC4
B002: 79                        	LD	A,C		;is desired sector now before current one?
B003: 95                        	SUB	L
B004: 78                        	LD	A,B
B005: 9C                        	SBC	A,H
B006: DA 0F B0                  	JP	C,TRKSEC4
B009: EB                        	EX	DE,HL		;not yes, increment track counter
B00A: E1                        	POP	HL		;and continue until it is.
B00B: 23                        	INC	HL
B00C: C3 FA AF                  	JP	TRKSEC3
                                ;
                                ;   here we have determined the track number that contains the
                                ; desired sector.
                                ;
B00F: E1                        TRKSEC4:POP	HL		;get track number (HL).
B010: C5                        	PUSH	BC
B011: D5                        	PUSH	DE
B012: E5                        	PUSH	HL
B013: EB                        	EX	DE,HL
B014: 2A CE B9                  	LD	HL,(OFFSET)	;adjust for first track offset.
B017: 19                        	ADD	HL,DE
B018: 44                        	LD	B,H
B019: 4D                        	LD	C,L
B01A: CD 3F BC                  	CALL	SETTRK		;select this track.
B01D: D1                        	POP	DE		;reset current track pointer.
B01E: 2A B5 B9                  	LD	HL,(SCRATCH2)
B021: 73                        	LD	(HL),E
B022: 23                        	INC	HL
B023: 72                        	LD	(HL),D
B024: D1                        	POP	DE
B025: 2A B7 B9                  	LD	HL,(SCRATCH3)	;reset the first sector on this track.
B028: 73                        	LD	(HL),E
B029: 23                        	INC	HL
B02A: 72                        	LD	(HL),D
B02B: C1                        	POP	BC
B02C: 79                        	LD	A,C		;now subtract the desired one.
B02D: 93                        	SUB	E		;to make it relative (1-# sectors/track).
B02E: 4F                        	LD	C,A
B02F: 78                        	LD	A,B
B030: 9A                        	SBC	A,D
B031: 47                        	LD	B,A
B032: 2A D0 B9                  	LD	HL,(XLATE)	;translate this sector according to this table.
B035: EB                        	EX	DE,HL
B036: CD 30 BA                  	CALL	SECTRN		;let the bios translate it.
B039: 4D                        	LD	C,L
B03A: 44                        	LD	B,H
B03B: C3 44 BC                  	JP	SETSEC		;and select it.
                                ;
                                ;   Compute block number from record number (SAVNREC) and
                                ; extent number (SAVEXT).
                                ;
B03E: 21 C3 B9                  GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
B041: 4E                        	LD	C,(HL)		;note that this is base 2 log of ratio.
B042: 3A E3 B9                  	LD	A,(SAVNREC)	;get record number.
B045: B7                        GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
B046: 1F                        	RRA	
B047: 0D                        	DEC	C
B048: C2 45 B0                  	JP	NZ,GETBLK1
B04B: 47                        	LD	B,A		;save result in (B).
B04C: 3E 08                     	LD	A,8
B04E: 96                        	SUB	(HL)
B04F: 4F                        	LD	C,A		;compute (C)=8-BLKSHFT.
B050: 3A E2 B9                  	LD	A,(SAVEXT)
B053: 0D                        GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
B054: CA 5C B0                  	JP	Z,GETBLK3
B057: B7                        	OR	A
B058: 17                        	RLA	
B059: C3 53 B0                  	JP	GETBLK2
B05C: 80                        GETBLK3:ADD	A,B
B05D: C9                        	RET	
                                ;
                                ;   Routine to extract the (BC) block byte from the fcb pointed
                                ; to by (PARAMS). If this is a big-disk, then these are 16 bit
                                ; block numbers, else they are 8 bit numbers.
                                ; Number is returned in (HL).
                                ;
B05E: 2A 43 AF                  EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
B061: 11 10 00                  	LD	DE,16		;block numbers start 16 bytes into fcb.
B064: 19                        	ADD	HL,DE
B065: 09                        	ADD	HL,BC
B066: 3A DD B9                  	LD	A,(BIGDISK)	;are we using a big-disk?
B069: B7                        	OR	A
B06A: CA 71 B0                  	JP	Z,EXTBLK1
B06D: 6E                        	LD	L,(HL)		;no, extract an 8 bit number from the fcb.
B06E: 26 00                     	LD	H,0
B070: C9                        	RET	
B071: 09                        EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
B072: 5E                        	LD	E,(HL)
B073: 23                        	INC	HL
B074: 56                        	LD	D,(HL)
B075: EB                        	EX	DE,HL		;return in (HL).
B076: C9                        	RET	
                                ;
                                ;   Compute block number.
                                ;
B077: CD 3E B0                  COMBLK:	CALL	GETBLOCK
B07A: 4F                        	LD	C,A
B07B: 06 00                     	LD	B,0
B07D: CD 5E B0                  	CALL	EXTBLK
B080: 22 E5 B9                  	LD	(BLKNMBR),HL
B083: C9                        	RET	
                                ;
                                ;   Check for a zero block number (unused).
                                ;
B084: 2A E5 B9                  CHKBLK:	LD	HL,(BLKNMBR)
B087: 7D                        	LD	A,L		;is it zero?
B088: B4                        	OR	H
B089: C9                        	RET	
                                ;
                                ;   Adjust physical block (BLKNMBR) and convert to logical
                                ; sector (LOGSECT). This is the starting sector of this block.
                                ; The actual sector of interest is then added to this and the
                                ; resulting sector number is stored back in (BLKNMBR). This
                                ; will still have to be adjusted for the track number.
                                ;
B08A: 3A C3 B9                  LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
B08D: 2A E5 B9                  	LD	HL,(BLKNMBR)	;get physical sector desired.
B090: 29                        LOGICL1:ADD	HL,HL		;compute logical sector number.
B091: 3D                        	DEC	A		;note logical sectors are 128 bytes long.
B092: C2 90 B0                  	JP	NZ,LOGICL1
B095: 22 E7 B9                  	LD	(LOGSECT),HL	;save logical sector.
B098: 3A C4 B9                  	LD	A,(BLKMASK)	;get block mask.
B09B: 4F                        	LD	C,A
B09C: 3A E3 B9                  	LD	A,(SAVNREC)	;get next sector to access.
B09F: A1                        	AND	C		;extract the relative position within physical block.
B0A0: B5                        	OR	L		;and add it too logical sector.
B0A1: 6F                        	LD	L,A
B0A2: 22 E5 B9                  	LD	(BLKNMBR),HL	;and store.
B0A5: C9                        	RET	
                                ;
                                ;   Set (HL) to point to extent byte in fcb.
                                ;
B0A6: 2A 43 AF                  SETEXT:	LD	HL,(PARAMS)
B0A9: 11 0C 00                  	LD	DE,12		;it is the twelth byte.
B0AC: 19                        	ADD	HL,DE
B0AD: C9                        	RET	
                                ;
                                ;   Set (HL) to point to record count byte in fcb and (DE) to
                                ; next record number byte.
                                ;
B0AE: 2A 43 AF                  SETHLDE:LD	HL,(PARAMS)
B0B1: 11 0F 00                  	LD	DE,15		;record count byte (#15).
B0B4: 19                        	ADD	HL,DE
B0B5: EB                        	EX	DE,HL
B0B6: 21 11 00                  	LD	HL,17		;next record number (#32).
B0B9: 19                        	ADD	HL,DE
B0BA: C9                        	RET	
                                ;
                                ;   Save current file data from fcb.
                                ;
B0BB: CD AE B0                  STRDATA:CALL	SETHLDE
B0BE: 7E                        	LD	A,(HL)		;get and store record count byte.
B0BF: 32 E3 B9                  	LD	(SAVNREC),A
B0C2: EB                        	EX	DE,HL
B0C3: 7E                        	LD	A,(HL)		;get and store next record number byte.
B0C4: 32 E1 B9                  	LD	(SAVNXT),A
B0C7: CD A6 B0                  	CALL	SETEXT		;point to extent byte.
B0CA: 3A C5 B9                  	LD	A,(EXTMASK)	;get extent mask.
B0CD: A6                        	AND	(HL)
B0CE: 32 E2 B9                  	LD	(SAVEXT),A	;and save extent here.
B0D1: C9                        	RET	
                                ;
                                ;   Set the next record to access. If (MODE) is set to 2, then
                                ; the last record byte (SAVNREC) has the correct number to access.
                                ; For sequential access, (MODE) will be equal to 1.
                                ;
B0D2: CD AE B0                  SETNREC:CALL	SETHLDE
B0D5: 3A D5 B9                  	LD	A,(MODE)	;get sequential flag (=1).
B0D8: FE 02                     	CP	2		;a 2 indicates that no adder is needed.
B0DA: C2 DE B0                  	JP	NZ,STNREC1
B0DD: AF                        	XOR	A		;clear adder (random access?).
B0DE: 4F                        STNREC1:LD	C,A
B0DF: 3A E3 B9                  	LD	A,(SAVNREC)	;get last record number.
B0E2: 81                        	ADD	A,C		;increment record count.
B0E3: 77                        	LD	(HL),A		;and set fcb's next record byte.
B0E4: EB                        	EX	DE,HL
B0E5: 3A E1 B9                  	LD	A,(SAVNXT)	;get next record byte from storage.
B0E8: 77                        	LD	(HL),A		;and put this into fcb as number of records used.
B0E9: C9                        	RET	
                                ;
                                ;   Shift (HL) right (C) bits.
                                ;
B0EA: 0C                        SHIFTR:	INC	C
B0EB: 0D                        SHIFTR1:DEC	C
B0EC: C8                        	RET	Z
B0ED: 7C                        	LD	A,H
B0EE: B7                        	OR	A
B0EF: 1F                        	RRA	
B0F0: 67                        	LD	H,A
B0F1: 7D                        	LD	A,L
B0F2: 1F                        	RRA	
B0F3: 6F                        	LD	L,A
B0F4: C3 EB B0                  	JP	SHIFTR1
                                ;
                                ;   Compute the check-sum for the directory buffer. Return
                                ; integer sum in (A).
                                ;
B0F7: 0E 80                     CHECKSUM: LD	C,128		;length of buffer.
B0F9: 2A B9 B9                  	LD	HL,(DIRBUF)	;get its location.
B0FC: AF                        	XOR	A		;clear summation byte.
B0FD: 86                        CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
B0FE: 23                        	INC	HL
B0FF: 0D                        	DEC	C
B100: C2 FD B0                  	JP	NZ,CHKSUM1
B103: C9                        	RET	
                                ;
                                ;   Shift (HL) left (C) bits.
                                ;
B104: 0C                        SHIFTL:	INC	C
B105: 0D                        SHIFTL1:DEC	C
B106: C8                        	RET	Z
B107: 29                        	ADD	HL,HL		;shift left 1 bit.
B108: C3 05 B1                  	JP	SHIFTL1
                                ;
                                ;   Routine to set a bit in a 16 bit value contained in (BC).
                                ; The bit set depends on the current drive selection.
                                ;
B10B: C5                        SETBIT:	PUSH	BC		;save 16 bit word.
B10C: 3A 42 AF                  	LD	A,(ACTIVE)	;get active drive.
B10F: 4F                        	LD	C,A
B110: 21 01 00                  	LD	HL,1
B113: CD 04 B1                  	CALL	SHIFTL		;shift bit 0 into place.
B116: C1                        	POP	BC		;now 'or' this with the original word.
B117: 79                        	LD	A,C
B118: B5                        	OR	L
B119: 6F                        	LD	L,A		;low byte done, do high byte.
B11A: 78                        	LD	A,B
B11B: B4                        	OR	H
B11C: 67                        	LD	H,A
B11D: C9                        	RET	
                                ;
                                ;   Extract the write protect status bit for the current drive.
                                ; The result is returned in (A), bit 0.
                                ;
B11E: 2A AD B9                  GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
B121: 3A 42 AF                  	LD	A,(ACTIVE)	;which drive is current?
B124: 4F                        	LD	C,A
B125: CD EA B0                  	CALL	SHIFTR		;shift status such that bit 0 is the
B128: 7D                        	LD	A,L		;one of interest for this drive.
B129: E6 01                     	AND	01H		;and isolate it.
B12B: C9                        	RET	
                                ;
                                ;   Function to write protect the current disk.
                                ;
B12C: 21 AD B9                  WRTPRTD:LD	HL,WRTPRT	;point to status word.
B12F: 4E                        	LD	C,(HL)		;set (BC) equal to the status.
B130: 23                        	INC	HL
B131: 46                        	LD	B,(HL)
B132: CD 0B B1                  	CALL	SETBIT		;and set this bit according to current drive.
B135: 22 AD B9                  	LD	(WRTPRT),HL	;then save.
B138: 2A C8 B9                  	LD	HL,(DIRSIZE)	;now save directory size limit.
B13B: 23                        	INC	HL		;remember the last one.
B13C: EB                        	EX	DE,HL
B13D: 2A B3 B9                  	LD	HL,(SCRATCH1)	;and store it here.
B140: 73                        	LD	(HL),E		;put low byte.
B141: 23                        	INC	HL
B142: 72                        	LD	(HL),D		;then high byte.
B143: C9                        	RET	
                                ;
                                ;   Check for a read only file.
                                ;
B144: CD 5E B1                  CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
B147: 11 09 00                  CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
B14A: 19                        	ADD	HL,DE
B14B: 7E                        	LD	A,(HL)
B14C: 17                        	RLA	
B14D: D0                        	RET	NC		;return if ok.
B14E: 21 0F AC                  	LD	HL,ROFILE	;else, print error message and terminate.
B151: C3 4A AF                  	JP	JUMPHL
                                ;
                                ;   Check the write protect status of the active disk.
                                ;
B154: CD 1E B1                  CHKWPRT:CALL	GETWPRT
B157: C8                        	RET	Z		;return if ok.
B158: 21 0D AC                  	LD	HL,RODISK	;else print message and terminate.
B15B: C3 4A AF                  	JP	JUMPHL
                                ;
                                ;   Routine to set (HL) pointing to the proper entry in the
                                ; directory buffer.
                                ;
B15E: 2A B9 B9                  FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
B161: 3A E9 B9                  	LD	A,(FCBPOS)	;relative position of file.
                                ;
                                ;   Routine to add (A) to (HL).
                                ;
B164: 85                        ADDA2HL:ADD	A,L
B165: 6F                        	LD	L,A
B166: D0                        	RET	NC
B167: 24                        	INC	H		;take care of any carry.
B168: C9                        	RET	
                                ;
                                ;   Routine to get the 's2' byte from the fcb supplied in
                                ; the initial parameter specification.
                                ;
B169: 2A 43 AF                  GETS2:	LD	HL,(PARAMS)	;get address of fcb.
B16C: 11 0E 00                  	LD	DE,14		;relative position of 's2'.
B16F: 19                        	ADD	HL,DE
B170: 7E                        	LD	A,(HL)		;extract this byte.
B171: C9                        	RET	
                                ;
                                ;   Clear the 's2' byte in the fcb.
                                ;
B172: CD 69 B1                  CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
B175: 36 00                     	LD	(HL),0		;now clear it.
B177: C9                        	RET	
                                ;
                                ;   Set bit 7 in the 's2' byte of the fcb.
                                ;
B178: CD 69 B1                  SETS2B7:CALL	GETS2		;get the byte.
B17B: F6 80                     	OR	80H		;and set bit 7.
B17D: 77                        	LD	(HL),A		;then store.
B17E: C9                        	RET	
                                ;
                                ;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
                                ; the difference. This checks to see if there are more file
                                ; names in the directory. We are at (FILEPOS) and there are
                                ; (SCRATCH1) of them to check.
                                ;
B17F: 2A EA B9                  MOREFLS:LD	HL,(FILEPOS)	;we are here.
B182: EB                        	EX	DE,HL
B183: 2A B3 B9                  	LD	HL,(SCRATCH1)	;and don't go past here.
B186: 7B                        	LD	A,E		;compute difference but don't keep.
B187: 96                        	SUB	(HL)
B188: 23                        	INC	HL
B189: 7A                        	LD	A,D
B18A: 9E                        	SBC	A,(HL)		;set carry if no more names.
B18B: C9                        	RET	
                                ;
                                ;   Call this routine to prevent (SCRATCH1) from being greater
                                ; than (FILEPOS).
                                ;
B18C: CD 7F B1                  CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
B18F: D8                        	RET	C
B190: 13                        	INC	DE		;yes, reset it to (FILEPOS).
B191: 72                        	LD	(HL),D
B192: 2B                        	DEC	HL
B193: 73                        	LD	(HL),E
B194: C9                        	RET	
                                ;
                                ;   Compute (HL)=(DE)-(HL)
                                ;
B195: 7B                        SUBHL:	LD	A,E		;compute difference.
B196: 95                        	SUB	L
B197: 6F                        	LD	L,A		;store low byte.
B198: 7A                        	LD	A,D
B199: 9C                        	SBC	A,H
B19A: 67                        	LD	H,A		;and then high byte.
B19B: C9                        	RET	
                                ;
                                ;   Set the directory checksum byte.
                                ;
B19C: 0E FF                     SETDIR:	LD	C,0FFH
                                ;
                                ;   Routine to set or compare the directory checksum byte. If
                                ; (C)=0ffh, then this will set the checksum byte. Else the byte
                                ; will be checked. If the check fails (the disk has been changed),
                                ; then this disk will be write protected.
                                ;
B19E: 2A EC B9                  CHECKDIR: LD	HL,(CKSUMTBL)
B1A1: EB                        	EX	DE,HL
B1A2: 2A CC B9                  	LD	HL,(ALLOC1)
B1A5: CD 95 B1                  	CALL	SUBHL
B1A8: D0                        	RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
B1A9: C5                        	PUSH	BC
B1AA: CD F7 B0                  	CALL	CHECKSUM	;else compute checksum.
B1AD: 2A BD B9                  	LD	HL,(CHKVECT)	;get address of checksum table.
B1B0: EB                        	EX	DE,HL
B1B1: 2A EC B9                  	LD	HL,(CKSUMTBL)
B1B4: 19                        	ADD	HL,DE		;set (HL) to point to byte for this drive.
B1B5: C1                        	POP	BC
B1B6: 0C                        	INC	C		;set or check ?
B1B7: CA C4 B1                  	JP	Z,CHKDIR1
B1BA: BE                        	CP	(HL)		;check them.
B1BB: C8                        	RET	Z		;return if they are the same.
B1BC: CD 7F B1                  	CALL	MOREFLS		;not the same, do we care?
B1BF: D0                        	RET	NC
B1C0: CD 2C B1                  	CALL	WRTPRTD		;yes, mark this as write protected.
B1C3: C9                        	RET	
B1C4: 77                        CHKDIR1:LD	(HL),A		;just set the byte.
B1C5: C9                        	RET	
                                ;
                                ;   Do a write to the directory of the current disk.
                                ;
B1C6: CD 9C B1                  DIRWRITE: CALL	SETDIR		;set checksum byte.
B1C9: CD E0 B1                  	CALL	DIRDMA		;set directory dma address.
B1CC: 0E 01                     	LD	C,1		;tell the bios to actually write.
B1CE: CD B8 AF                  	CALL	DOWRITE		;then do the write.
B1D1: C3 DA B1                  	JP	DEFDMA
                                ;
                                ;   Read from the directory.
                                ;
B1D4: CD E0 B1                  DIRREAD:CALL	DIRDMA		;set the directory dma address.
B1D7: CD B2 AF                  	CALL	DOREAD		;and read it.
                                ;
                                ;   Routine to set the dma address to the users choice.
                                ;
B1DA: 21 B1 B9                  DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
B1DD: C3 E3 B1                  	JP	DIRDMA1
                                ;
                                ;   Routine to set the dma address for directory work.
                                ;
B1E0: 21 B9 B9                  DIRDMA:	LD	HL,DIRBUF
                                ;
                                ;   Set the dma address. On entry, (HL) points to
                                ; word containing the desired dma address.
                                ;
B1E3: 4E                        DIRDMA1:LD	C,(HL)
B1E4: 23                        	INC	HL
B1E5: 46                        	LD	B,(HL)		;setup (BC) and go to the bios to set it.
B1E6: C3 4F BC                  	JP	SETDMA
                                ;
                                ;   Move the directory buffer into user's dma space.
                                ;
B1E9: 2A B9 B9                  MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
B1EC: EB                        	EX	DE,HL
B1ED: 2A B1 B9                  	LD	HL,(USERDMA)	; put it here.
B1F0: 0E 80                     	LD	C,128		;this is its length.
B1F2: C3 4F AF                  	JP	DE2HL		;move it now and return.
                                ;
                                ;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
                                ;
B1F5: 21 EA B9                  CKFILPOS: LD	HL,FILEPOS
B1F8: 7E                        	LD	A,(HL)
B1F9: 23                        	INC	HL
B1FA: BE                        	CP	(HL)		;are both bytes the same?
B1FB: C0                        	RET	NZ
B1FC: 3C                        	INC	A		;yes, but are they each 0ffh?
B1FD: C9                        	RET	
                                ;
                                ;   Set location (FILEPOS) to 0ffffh.
                                ;
B1FE: 21 FF FF                  STFILPOS: LD	HL,0FFFFH
B201: 22 EA B9                  	LD	(FILEPOS),HL
B204: C9                        	RET	
                                ;
                                ;   Move on to the next file position within the current
                                ; directory buffer. If no more exist, set pointer to 0ffffh
                                ; and the calling routine will check for this. Enter with (C)
                                ; equal to 0ffh to cause the checksum byte to be set, else we
                                ; will check this disk and set write protect if checksums are
                                ; not the same (applies only if another directory sector must
                                ; be read).
                                ;
B205: 2A C8 B9                  NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
B208: EB                        	EX	DE,HL
B209: 2A EA B9                  	LD	HL,(FILEPOS)	;get current count.
B20C: 23                        	INC	HL		;go on to the next one.
B20D: 22 EA B9                  	LD	(FILEPOS),HL
B210: CD 95 B1                  	CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
B213: D2 19 B2                  	JP	NC,NXENT1	;is there more room left?
B216: C3 FE B1                  	JP	STFILPOS	;no. Set this flag and return.
B219: 3A EA B9                  NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
B21C: E6 03                     	AND	03H		;only look within this sector (only 4 entries fit).
B21E: 06 05                     	LD	B,5		;convert to relative position (32 bytes each).
B220: 87                        NXENT2:	ADD	A,A		;note that this is not efficient code.
B221: 05                        	DEC	B		;5 'ADD A's would be better.
B222: C2 20 B2                  	JP	NZ,NXENT2
B225: 32 E9 B9                  	LD	(FCBPOS),A	;save it as position of fcb.
B228: B7                        	OR	A
B229: C0                        	RET	NZ		;return if we are within buffer.
B22A: C5                        	PUSH	BC
B22B: CD C3 AF                  	CALL	TRKSEC		;we need the next directory sector.
B22E: CD D4 B1                  	CALL	DIRREAD
B231: C1                        	POP	BC
B232: C3 9E B1                  	JP	CHECKDIR
                                ;
                                ;   Routine to to get a bit from the disk space allocation
                                ; map. It is returned in (A), bit position 0. On entry to here,
                                ; set (BC) to the block number on the disk to check.
                                ; On return, (D) will contain the original bit position for
                                ; this block number and (HL) will point to the address for it.
                                ;
B235: 79                        CKBITMAP: LD	A,C		;determine bit number of interest.
B236: E6 07                     	AND	07H		;compute (D)=(E)=(C and 7)+1.
B238: 3C                        	INC	A
B239: 5F                        	LD	E,A		;save particular bit number.
B23A: 57                        	LD	D,A
                                ;
                                ;   compute (BC)=(BC)/8.
                                ;
B23B: 79                        	LD	A,C
B23C: 0F                        	RRCA			;now shift right 3 bits.
B23D: 0F                        	RRCA	
B23E: 0F                        	RRCA	
B23F: E6 1F                     	AND	1FH		;and clear bits 7,6,5.
B241: 4F                        	LD	C,A
B242: 78                        	LD	A,B
B243: 87                        	ADD	A,A		;now shift (B) into bits 7,6,5.
B244: 87                        	ADD	A,A
B245: 87                        	ADD	A,A
B246: 87                        	ADD	A,A
B247: 87                        	ADD	A,A
B248: B1                        	OR	C		;and add in (C).
B249: 4F                        	LD	C,A		;ok, (C) ha been completed.
B24A: 78                        	LD	A,B		;is there a better way of doing this?
B24B: 0F                        	RRCA	
B24C: 0F                        	RRCA	
B24D: 0F                        	RRCA	
B24E: E6 1F                     	AND	1FH
B250: 47                        	LD	B,A		;and now (B) is completed.
                                ;
                                ;   use this as an offset into the disk space allocation
                                ; table.
                                ;
B251: 2A BF B9                  	LD	HL,(ALOCVECT)
B254: 09                        	ADD	HL,BC
B255: 7E                        	LD	A,(HL)		;now get correct byte.
B256: 07                        CKBMAP1:RLCA			;get correct bit into position 0.
B257: 1D                        	DEC	E
B258: C2 56 B2                  	JP	NZ,CKBMAP1
B25B: C9                        	RET	
                                ;
                                ;   Set or clear the bit map such that block number (BC) will be marked
                                ; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
                                ; 1 then it will be set (don't use anyother values).
                                ;
B25C: D5                        STBITMAP: PUSH	DE
B25D: CD 35 B2                  	CALL	CKBITMAP	;get the byte of interest.
B260: E6 FE                     	AND	0FEH		;clear the affected bit.
B262: C1                        	POP	BC
B263: B1                        	OR	C		;and now set it acording to (C).
                                ;
                                ;  entry to restore the original bit position and then store
                                ; in table. (A) contains the value, (D) contains the bit
                                ; position (1-8), and (HL) points to the address within the
                                ; space allocation table for this byte.
                                ;
B264: 0F                        STBMAP1:RRCA			;restore original bit position.
B265: 15                        	DEC	D
B266: C2 64 B2                  	JP	NZ,STBMAP1
B269: 77                        	LD	(HL),A		;and stor byte in table.
B26A: C9                        	RET	
                                ;
                                ;   Set/clear space used bits in allocation map for this file.
                                ; On entry, (C)=1 to set the map and (C)=0 to clear it.
                                ;
B26B: CD 5E B1                  SETFILE:CALL	FCB2HL		;get address of fcb
B26E: 11 10 00                  	LD	DE,16
B271: 19                        	ADD	HL,DE		;get to block number bytes.
B272: C5                        	PUSH	BC
B273: 0E 11                     	LD	C,17		;check all 17 bytes (max) of table.
B275: D1                        SETFL1:	POP	DE
B276: 0D                        	DEC	C		;done all bytes yet?
B277: C8                        	RET	Z
B278: D5                        	PUSH	DE
B279: 3A DD B9                  	LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
B27C: B7                        	OR	A
B27D: CA 88 B2                  	JP	Z,SETFL2
B280: C5                        	PUSH	BC		;only 8 bit numbers. set (BC) to this one.
B281: E5                        	PUSH	HL
B282: 4E                        	LD	C,(HL)		;get low byte from table, always
B283: 06 00                     	LD	B,0		;set high byte to zero.
B285: C3 8E B2                  	JP	SETFL3
B288: 0D                        SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
B289: C5                        	PUSH	BC
B28A: 4E                        	LD	C,(HL)		;now get both the low and high bytes.
B28B: 23                        	INC	HL
B28C: 46                        	LD	B,(HL)
B28D: E5                        	PUSH	HL
B28E: 79                        SETFL3:	LD	A,C		;block used?
B28F: B0                        	OR	B
B290: CA 9D B2                  	JP	Z,SETFL4
B293: 2A C6 B9                  	LD	HL,(DSKSIZE)	;is this block number within the
B296: 7D                        	LD	A,L		;space on the disk?
B297: 91                        	SUB	C
B298: 7C                        	LD	A,H
B299: 98                        	SBC	A,B
B29A: D4 5C B2                  	CALL	NC,STBITMAP	;yes, set the proper bit.
B29D: E1                        SETFL4:	POP	HL		;point to next block number in fcb.
B29E: 23                        	INC	HL
B29F: C1                        	POP	BC
B2A0: C3 75 B2                  	JP	SETFL1
                                ;
                                ;   Construct the space used allocation bit map for the active
                                ; drive. If a file name starts with '$' and it is under the
                                ; current user number, then (STATUS) is set to minus 1. Otherwise
                                ; it is not set at all.
                                ;
B2A3: 2A C6 B9                  BITMAAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
B2A6: 0E 03                     	LD	C,3
B2A8: CD EA B0                  	CALL	SHIFTR		;(HL)=(HL)/8.
B2AB: 23                        	INC	HL		;at lease 1 byte.
B2AC: 44                        	LD	B,H
B2AD: 4D                        	LD	C,L		;set (BC) to the allocation table length.
                                ;
                                ;   Initialize the bitmap for this drive. Right now, the first
                                ; two bytes are specified by the disk parameter block. However
                                ; a patch could be entered here if it were necessary to setup
                                ; this table in a special mannor. For example, the bios could
                                ; determine locations of 'bad blocks' and set them as already
                                ; 'used' in the map.
                                ;
B2AE: 2A BF B9                  	LD	HL,(ALOCVECT)	;now zero out the table now.
B2B1: 36 00                     BITMAP1:LD	(HL),0
B2B3: 23                        	INC	HL
B2B4: 0B                        	DEC	BC
B2B5: 78                        	LD	A,B
B2B6: B1                        	OR	C
B2B7: C2 B1 B2                  	JP	NZ,BITMAP1
B2BA: 2A CA B9                  	LD	HL,(ALLOC0)	;get initial space used by directory.
B2BD: EB                        	EX	DE,HL
B2BE: 2A BF B9                  	LD	HL,(ALOCVECT)	;and put this into map.
B2C1: 73                        	LD	(HL),E
B2C2: 23                        	INC	HL
B2C3: 72                        	LD	(HL),D
                                ;
                                ;   End of initialization portion.
                                ;
B2C4: CD A1 AF                  	CALL	HOMEDRV		;now home the drive.
B2C7: 2A B3 B9                  	LD	HL,(SCRATCH1)
B2CA: 36 03                     	LD	(HL),3		;force next directory request to read
B2CC: 23                        	INC	HL		;in a sector.
B2CD: 36 00                     	LD	(HL),0
B2CF: CD FE B1                  	CALL	STFILPOS	;clear initial file position also.
B2D2: 0E FF                     BITMAP2:LD	C,0FFH		;read next file name in directory
B2D4: CD 05 B2                  	CALL	NXENTRY		;and set checksum byte.
B2D7: CD F5 B1                  	CALL	CKFILPOS	;is there another file?
B2DA: C8                        	RET	Z
B2DB: CD 5E B1                  	CALL	FCB2HL		;yes, get its address.
B2DE: 3E E5                     	LD	A,0E5H
B2E0: BE                        	CP	(HL)		;empty file entry?
B2E1: CA D2 B2                  	JP	Z,BITMAP2
B2E4: 3A 41 AF                  	LD	A,(USERNO)	;no, correct user number?
B2E7: BE                        	CP	(HL)
B2E8: C2 F6 B2                  	JP	NZ,BITMAP3
B2EB: 23                        	INC	HL
B2EC: 7E                        	LD	A,(HL)		;yes, does name start with a '$'?
B2ED: D6 24                     	SUB	'$'
B2EF: C2 F6 B2                  	JP	NZ,BITMAP3
B2F2: 3D                        	DEC	A		;yes, set atatus to minus one.
B2F3: 32 45 AF                  	LD	(STATUS),A
B2F6: 0E 01                     BITMAP3:LD	C,1		;now set this file's space as used in bit map.
B2F8: CD 6B B2                  	CALL	SETFILE
B2FB: CD 8C B1                  	CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
B2FE: C3 D2 B2                  	JP	BITMAP2
                                ;
                                ;   Set the status (STATUS) and return.
                                ;
B301: 3A D4 B9                  STSTATUS: LD	A,(FNDSTAT)
B304: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;   Check extents in (A) and (C). Set the zero flag if they
                                ; are the same. The number of 16k chunks of disk space that
                                ; the directory extent covers is expressad is (EXTMASK+1).
                                ; No registers are modified.
                                ;
B307: C5                        SAMEXT:	PUSH	BC
B308: F5                        	PUSH	AF
B309: 3A C5 B9                  	LD	A,(EXTMASK)	;get extent mask and use it to
B30C: 2F                        	CPL			;to compare both extent numbers.
B30D: 47                        	LD	B,A		;save resulting mask here.
B30E: 79                        	LD	A,C		;mask first extent and save in (C).
B30F: A0                        	AND	B
B310: 4F                        	LD	C,A
B311: F1                        	POP	AF		;now mask second extent and compare
B312: A0                        	AND	B		;with the first one.
B313: 91                        	SUB	C
B314: E6 1F                     	AND	1FH		;(* only check buts 0-4 *)
B316: C1                        	POP	BC		;the zero flag is set if they are the same.
B317: C9                        	RET			;restore (BC) and return.
                                ;
                                ;   Search for the first occurence of a file name. On entry,
                                ; register (C) should contain the number of bytes of the fcb
                                ; that must match.
                                ;
B318: 3E FF                     FINDFST:LD	A,0FFH
B31A: 32 D4 B9                  	LD	(FNDSTAT),A
B31D: 21 D8 B9                  	LD	HL,COUNTER	;save character count.
B320: 71                        	LD	(HL),C
B321: 2A 43 AF                  	LD	HL,(PARAMS)	;get filename to match.
B324: 22 D9 B9                  	LD	(SAVEFCB),HL	;and save.
B327: CD FE B1                  	CALL	STFILPOS	;clear initial file position (set to 0ffffh).
B32A: CD A1 AF                  	CALL	HOMEDRV		;home the drive.
                                ;
                                ;   Entry to locate the next occurence of a filename within the
                                ; directory. The disk is not expected to have been changed. If
                                ; it was, then it will be write protected.
                                ;
B32D: 0E 00                     FINDNXT:LD	C,0		;write protect the disk if changed.
B32F: CD 05 B2                  	CALL	NXENTRY		;get next filename entry in directory.
B332: CD F5 B1                  	CALL	CKFILPOS	;is file position = 0ffffh?
B335: CA 94 B3                  	JP	Z,FNDNXT6	;yes, exit now then.
B338: 2A D9 B9                  	LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
B33B: EB                        	EX	DE,HL
B33C: 1A                        	LD	A,(DE)
B33D: FE E5                     	CP	0E5H		;empty directory entry?
B33F: CA 4A B3                  	JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
B342: D5                        	PUSH	DE
B343: CD 7F B1                  	CALL	MOREFLS		;more files in directory?
B346: D1                        	POP	DE
B347: D2 94 B3                  	JP	NC,FNDNXT6	;no more. Exit now.
B34A: CD 5E B1                  FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
B34D: 3A D8 B9                  	LD	A,(COUNTER)	;get number of bytes (characters) to check.
B350: 4F                        	LD	C,A
B351: 06 00                     	LD	B,0		;initialize byte position counter.
B353: 79                        FNDNXT2:LD	A,C		;are we done with the compare?
B354: B7                        	OR	A
B355: CA 83 B3                  	JP	Z,FNDNXT5
B358: 1A                        	LD	A,(DE)		;no, check next byte.
B359: FE 3F                     	CP	'?'		;don't care about this character?
B35B: CA 7C B3                  	JP	Z,FNDNXT4
B35E: 78                        	LD	A,B		;get bytes position in fcb.
B35F: FE 0D                     	CP	13		;don't care about the thirteenth byte either.
B361: CA 7C B3                  	JP	Z,FNDNXT4
B364: FE 0C                     	CP	12		;extent byte?
B366: 1A                        	LD	A,(DE)
B367: CA 73 B3                  	JP	Z,FNDNXT3
B36A: 96                        	SUB	(HL)		;otherwise compare characters.
B36B: E6 7F                     	AND	7FH
B36D: C2 2D B3                  	JP	NZ,FINDNXT	;not the same, check next entry.
B370: C3 7C B3                  	JP	FNDNXT4		;so far so good, keep checking.
B373: C5                        FNDNXT3:PUSH	BC		;check the extent byte here.
B374: 4E                        	LD	C,(HL)
B375: CD 07 B3                  	CALL	SAMEXT
B378: C1                        	POP	BC
B379: C2 2D B3                  	JP	NZ,FINDNXT	;not the same, look some more.
                                ;
                                ;   So far the names compare. Bump pointers to the next byte
                                ; and continue until all (C) characters have been checked.
                                ;
B37C: 13                        FNDNXT4:INC	DE		;bump pointers.
B37D: 23                        	INC	HL
B37E: 04                        	INC	B
B37F: 0D                        	DEC	C		;adjust character counter.
B380: C3 53 B3                  	JP	FNDNXT2
B383: 3A EA B9                  FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
B386: E6 03                     	AND	03H
B388: 32 45 AF                  	LD	(STATUS),A
B38B: 21 D4 B9                  	LD	HL,FNDSTAT
B38E: 7E                        	LD	A,(HL)
B38F: 17                        	RLA	
B390: D0                        	RET	NC
B391: AF                        	XOR	A
B392: 77                        	LD	(HL),A
B393: C9                        	RET	
                                ;
                                ;   Filename was not found. Set appropriate status.
                                ;
B394: CD FE B1                  FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
B397: 3E FF                     	LD	A,0FFH		;say not located.
B399: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;   Erase files from the directory. Only the first byte of the
                                ; fcb will be affected. It is set to (E5).
                                ;
B39C: CD 54 B1                  ERAFILE:CALL	CHKWPRT		;is disk write protected?
B39F: 0E 0C                     	LD	C,12		;only compare file names.
B3A1: CD 18 B3                  	CALL	FINDFST		;get first file name.
B3A4: CD F5 B1                  ERAFIL1:CALL	CKFILPOS	;any found?
B3A7: C8                        	RET	Z		;nope, we must be done.
B3A8: CD 44 B1                  	CALL	CHKROFL		;is file read only?
B3AB: CD 5E B1                  	CALL	FCB2HL		;nope, get address of fcb and
B3AE: 36 E5                     	LD	(HL),0E5H	;set first byte to 'empty'.
B3B0: 0E 00                     	LD	C,0		;clear the space from the bit map.
B3B2: CD 6B B2                  	CALL	SETFILE
B3B5: CD C6 B1                  	CALL	DIRWRITE	;now write the directory sector back out.
B3B8: CD 2D B3                  	CALL	FINDNXT		;find the next file name.
B3BB: C3 A4 B3                  	JP	ERAFIL1		;and repeat process.
                                ;
                                ;   Look through the space allocation map (bit map) for the
                                ; next available block. Start searching at block number (BC-1).
                                ; The search procedure is to look for an empty block that is
                                ; before the starting block. If not empty, look at a later
                                ; block number. In this way, we return the closest empty block
                                ; on either side of the 'target' block number. This will speed
                                ; access on random devices. For serial devices, this should be
                                ; changed to look in the forward direction first and then start
                                ; at the front and search some more.
                                ;
                                ;   On return, (DE)= block number that is empty and (HL) =0
                                ; if no empry block was found.
                                ;
B3BE: 50                        FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
B3BF: 59                        	LD	E,C
                                ;
                                ;   Look before target block. Registers (BC) are used as the lower
                                ; pointer and (DE) as the upper pointer.
                                ;
B3C0: 79                        FNDSPA1:LD	A,C		;is block 0 specified?
B3C1: B0                        	OR	B
B3C2: CA D1 B3                  	JP	Z,FNDSPA2
B3C5: 0B                        	DEC	BC		;nope, check previous block.
B3C6: D5                        	PUSH	DE
B3C7: C5                        	PUSH	BC
B3C8: CD 35 B2                  	CALL	CKBITMAP
B3CB: 1F                        	RRA			;is this block empty?
B3CC: D2 EC B3                  	JP	NC,FNDSPA3	;yes. use this.
                                ;
                                ;   Note that the above logic gets the first block that it finds
                                ; that is empty. Thus a file could be written 'backward' making
                                ; it very slow to access. This could be changed to look for the
                                ; first empty block and then continue until the start of this
                                ; empty space is located and then used that starting block.
                                ; This should help speed up access to some files especially on
                                ; a well used disk with lots of fairly small 'holes'.
                                ;
B3CF: C1                        	POP	BC		;nope, check some more.
B3D0: D1                        	POP	DE
                                ;
                                ;   Now look after target block.
                                ;
B3D1: 2A C6 B9                  FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
B3D4: 7B                        	LD	A,E
B3D5: 95                        	SUB	L
B3D6: 7A                        	LD	A,D
B3D7: 9C                        	SBC	A,H
B3D8: D2 F4 B3                  	JP	NC,FNDSPA4
B3DB: 13                        	INC	DE		;yes, move on to next one.
B3DC: C5                        	PUSH	BC
B3DD: D5                        	PUSH	DE
B3DE: 42                        	LD	B,D
B3DF: 4B                        	LD	C,E
B3E0: CD 35 B2                  	CALL	CKBITMAP	;check it.
B3E3: 1F                        	RRA			;empty?
B3E4: D2 EC B3                  	JP	NC,FNDSPA3
B3E7: D1                        	POP	DE		;nope, continue searching.
B3E8: C1                        	POP	BC
B3E9: C3 C0 B3                  	JP	FNDSPA1
                                ;
                                ;   Empty block found. Set it as used and return with (HL)
                                ; pointing to it (true?).
                                ;
B3EC: 17                        FNDSPA3:RLA			;reset byte.
B3ED: 3C                        	INC	A		;and set bit 0.
B3EE: CD 64 B2                  	CALL	STBMAP1		;update bit map.
B3F1: E1                        	POP	HL		;set return registers.
B3F2: D1                        	POP	DE
B3F3: C9                        	RET	
                                ;
                                ;   Free block was not found. If (BC) is not zero, then we have
                                ; not checked all of the disk space.
                                ;
B3F4: 79                        FNDSPA4:LD	A,C
B3F5: B0                        	OR	B
B3F6: C2 C0 B3                  	JP	NZ,FNDSPA1
B3F9: 21 00 00                  	LD	HL,0		;set 'not found' status.
B3FC: C9                        	RET	
                                ;
                                ;   Move a complete fcb entry into the directory and write it.
                                ;
B3FD: 0E 00                     FCBSET:	LD	C,0
B3FF: 1E 20                     	LD	E,32		;length of each entry.
                                ;
                                ;   Move (E) bytes from the fcb pointed to by (PARAMS) into
                                ; fcb in directory starting at relative byte (C). This updated
                                ; directory buffer is then written to the disk.
                                ;
B401: D5                        UPDATE:	PUSH	DE
B402: 06 00                     	LD	B,0		;set (BC) to relative byte position.
B404: 2A 43 AF                  	LD	HL,(PARAMS)	;get address of fcb.
B407: 09                        	ADD	HL,BC		;compute starting byte.
B408: EB                        	EX	DE,HL
B409: CD 5E B1                  	CALL	FCB2HL		;get address of fcb to update in directory.
B40C: C1                        	POP	BC		;set (C) to number of bytes to change.
B40D: CD 4F AF                  	CALL	DE2HL
B410: CD C3 AF                  UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
B413: C3 C6 B1                  	JP	DIRWRITE	;then write this sector out.
                                ;
                                ;   Routine to change the name of all files on the disk with a
                                ; specified name. The fcb contains the current name as the
                                ; first 12 characters and the new name 16 bytes into the fcb.
                                ;
B416: CD 54 B1                  CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
B419: 0E 0C                     	LD	C,12		;match first 12 bytes of fcb only.
B41B: CD 18 B3                  	CALL	FINDFST		;get first name.
B41E: 2A 43 AF                  	LD	HL,(PARAMS)	;get address of fcb.
B421: 7E                        	LD	A,(HL)		;get user number.
B422: 11 10 00                  	LD	DE,16		;move over to desired name.
B425: 19                        	ADD	HL,DE
B426: 77                        	LD	(HL),A		;keep same user number.
B427: CD F5 B1                  CHGNAM1:CALL	CKFILPOS	;any matching file found?
B42A: C8                        	RET	Z		;no, we must be done.
B42B: CD 44 B1                  	CALL	CHKROFL		;check for read only file.
B42E: 0E 10                     	LD	C,16		;start 16 bytes into fcb.
B430: 1E 0C                     	LD	E,12		;and update the first 12 bytes of directory.
B432: CD 01 B4                  	CALL	UPDATE
B435: CD 2D B3                  	CALL	FINDNXT		;get te next file name.
B438: C3 27 B4                  	JP	CHGNAM1		;and continue.
                                ;
                                ;   Update a files attributes. The procedure is to search for
                                ; every file with the same name as shown in fcb (ignoring bit 7)
                                ; and then to update it (which includes bit 7). No other changes
                                ; are made.
                                ;
B43B: 0E 0C                     SAVEATTR: LD	C,12		;match first 12 bytes.
B43D: CD 18 B3                  	CALL	FINDFST		;look for first filename.
B440: CD F5 B1                  SAVATR1:CALL	CKFILPOS	;was one found?
B443: C8                        	RET	Z		;nope, we must be done.
B444: 0E 00                     	LD	C,0		;yes, update the first 12 bytes now.
B446: 1E 0C                     	LD	E,12
B448: CD 01 B4                  	CALL	UPDATE		;update filename and write directory.
B44B: CD 2D B3                  	CALL	FINDNXT		;and get the next file.
B44E: C3 40 B4                  	JP	SAVATR1		;then continue until done.
                                ;
                                ;  Open a file (name specified in fcb).
                                ;
B451: 0E 0F                     OPENIT:	LD	C,15		;compare the first 15 bytes.
B453: CD 18 B3                  	CALL	FINDFST		;get the first one in directory.
B456: CD F5 B1                  	CALL	CKFILPOS	;any at all?
B459: C8                        	RET	Z
B45A: CD A6 B0                  OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
B45D: 7E                        	LD	A,(HL)		;and get it.
B45E: F5                        	PUSH	AF		;save it and address.
B45F: E5                        	PUSH	HL
B460: CD 5E B1                  	CALL	FCB2HL		;point to fcb in directory.
B463: EB                        	EX	DE,HL
B464: 2A 43 AF                  	LD	HL,(PARAMS)	;this is the users copy.
B467: 0E 20                     	LD	C,32		;move it into users space.
B469: D5                        	PUSH	DE
B46A: CD 4F AF                  	CALL	DE2HL
B46D: CD 78 B1                  	CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
B470: D1                        	POP	DE		;now get the extent byte from this fcb.
B471: 21 0C 00                  	LD	HL,12
B474: 19                        	ADD	HL,DE
B475: 4E                        	LD	C,(HL)		;into (C).
B476: 21 0F 00                  	LD	HL,15		;now get the record count byte into (B).
B479: 19                        	ADD	HL,DE
B47A: 46                        	LD	B,(HL)
B47B: E1                        	POP	HL		;keep the same extent as the user had originally.
B47C: F1                        	POP	AF
B47D: 77                        	LD	(HL),A
B47E: 79                        	LD	A,C		;is it the same as in the directory fcb?
B47F: BE                        	CP	(HL)
B480: 78                        	LD	A,B		;if yes, then use the same record count.
B481: CA 8B B4                  	JP	Z,OPENIT2
B484: 3E 00                     	LD	A,0		;if the user specified an extent greater than
B486: DA 8B B4                  	JP	C,OPENIT2	;the one in the directory, then set record count to 0.
B489: 3E 80                     	LD	A,128		;otherwise set to maximum.
B48B: 2A 43 AF                  OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
B48E: 11 0F 00                  	LD	DE,15
B491: 19                        	ADD	HL,DE		;compute relative position.
B492: 77                        	LD	(HL),A		;and set the record count.
B493: C9                        	RET	
                                ;
                                ;   Move two bytes from (DE) to (HL) if (and only if) (HL)
                                ; point to a zero value (16 bit).
                                ;   Return with zero flag set it (DE) was moved. Registers (DE)
                                ; and (HL) are not changed. However (A) is.
                                ;
B494: 7E                        MOVEWORD: LD	A,(HL)		;check for a zero word.
B495: 23                        	INC	HL
B496: B6                        	OR	(HL)		;both bytes zero?
B497: 2B                        	DEC	HL
B498: C0                        	RET	NZ		;nope, just return.
B499: 1A                        	LD	A,(DE)		;yes, move two bytes from (DE) into
B49A: 77                        	LD	(HL),A		;this zero space.
B49B: 13                        	INC	DE
B49C: 23                        	INC	HL
B49D: 1A                        	LD	A,(DE)
B49E: 77                        	LD	(HL),A
B49F: 1B                        	DEC	DE		;don't disturb these registers.
B4A0: 2B                        	DEC	HL
B4A1: C9                        	RET	
                                ;
                                ;   Get here to close a file specified by (fcb).
                                ;
B4A2: AF                        CLOSEIT:XOR	A		;clear status and file position bytes.
B4A3: 32 45 AF                  	LD	(STATUS),A
B4A6: 32 EA B9                  	LD	(FILEPOS),A
B4A9: 32 EB B9                  	LD	(FILEPOS+1),A
B4AC: CD 1E B1                  	CALL	GETWPRT		;get write protect bit for this drive.
B4AF: C0                        	RET	NZ		;just return if it is set.
B4B0: CD 69 B1                  	CALL	GETS2		;else get the 's2' byte.
B4B3: E6 80                     	AND	80H		;and look at bit 7 (file unmodified?).
B4B5: C0                        	RET	NZ		;just return if set.
B4B6: 0E 0F                     	LD	C,15		;else look up this file in directory.
B4B8: CD 18 B3                  	CALL	FINDFST
B4BB: CD F5 B1                  	CALL	CKFILPOS	;was it found?
B4BE: C8                        	RET	Z		;just return if not.
B4BF: 01 10 00                  	LD	BC,16		;set (HL) pointing to records used section.
B4C2: CD 5E B1                  	CALL	FCB2HL
B4C5: 09                        	ADD	HL,BC
B4C6: EB                        	EX	DE,HL
B4C7: 2A 43 AF                  	LD	HL,(PARAMS)	;do the same for users specified fcb.
B4CA: 09                        	ADD	HL,BC
B4CB: 0E 10                     	LD	C,16		;this many bytes are present in this extent.
B4CD: 3A DD B9                  CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
B4D0: B7                        	OR	A
B4D1: CA E8 B4                  	JP	Z,CLOSEIT4
B4D4: 7E                        	LD	A,(HL)		;just 8 bit. Get one from users fcb.
B4D5: B7                        	OR	A
B4D6: 1A                        	LD	A,(DE)		;now get one from directory fcb.
B4D7: C2 DB B4                  	JP	NZ,CLOSEIT2
B4DA: 77                        	LD	(HL),A		;users byte was zero. Update from directory.
B4DB: B7                        CLOSEIT2: OR	A
B4DC: C2 E1 B4                  	JP	NZ,CLOSEIT3
B4DF: 7E                        	LD	A,(HL)		;directories byte was zero, update from users fcb.
B4E0: 12                        	LD	(DE),A
B4E1: BE                        CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
B4E2: C2 1F B5                  	JP	NZ,CLOSEIT7	;then close error if they are not the same.
B4E5: C3 FD B4                  	JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
B4E8: CD 94 B4                  CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
B4EB: EB                        	EX	DE,HL
B4EC: CD 94 B4                  	CALL	MOVEWORD	;update directories fcb if it is zero.
B4EF: EB                        	EX	DE,HL
B4F0: 1A                        	LD	A,(DE)		;if these two values are no different,
B4F1: BE                        	CP	(HL)		;then a close error occured.
B4F2: C2 1F B5                  	JP	NZ,CLOSEIT7
B4F5: 13                        	INC	DE		;check second byte.
B4F6: 23                        	INC	HL
B4F7: 1A                        	LD	A,(DE)
B4F8: BE                        	CP	(HL)
B4F9: C2 1F B5                  	JP	NZ,CLOSEIT7
B4FC: 0D                        	DEC	C		;remember 16 bit values.
B4FD: 13                        CLOSEIT5: INC	DE		;bump to next item in table.
B4FE: 23                        	INC	HL
B4FF: 0D                        	DEC	C		;there are 16 entries only.
B500: C2 CD B4                  	JP	NZ,CLOSEIT1	;continue if more to do.
B503: 01 EC FF                  	LD	BC,0FFECH	;backup 20 places (extent byte).
B506: 09                        	ADD	HL,BC
B507: EB                        	EX	DE,HL
B508: 09                        	ADD	HL,BC
B509: 1A                        	LD	A,(DE)
B50A: BE                        	CP	(HL)		;directory's extent already greater than the
B50B: DA 17 B5                  	JP	C,CLOSEIT6	;users extent?
B50E: 77                        	LD	(HL),A		;no, update directory extent.
B50F: 01 03 00                  	LD	BC,3		;and update the record count byte in
B512: 09                        	ADD	HL,BC		;directories fcb.
B513: EB                        	EX	DE,HL
B514: 09                        	ADD	HL,BC
B515: 7E                        	LD	A,(HL)		;get from user.
B516: 12                        	LD	(DE),A		;and put in directory.
B517: 3E FF                     CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
B519: 32 D2 B9                  	LD	(CLOSEFLG),A
B51C: C3 10 B4                  	JP	UPDATE1		;update the directory now.
B51F: 21 45 AF                  CLOSEIT7: LD	HL,STATUS	;set return status and then return.
B522: 35                        	DEC	(HL)
B523: C9                        	RET	
                                ;
                                ;   Routine to get the next empty space in the directory. It
                                ; will then be cleared for use.
                                ;
B524: CD 54 B1                  GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
B527: 2A 43 AF                  	LD	HL,(PARAMS)	;save current parameters (fcb).
B52A: E5                        	PUSH	HL
B52B: 21 AC B9                  	LD	HL,EMPTYFCB	;use special one for empty space.
B52E: 22 43 AF                  	LD	(PARAMS),HL
B531: 0E 01                     	LD	C,1		;search for first empty spot in directory.
B533: CD 18 B3                  	CALL	FINDFST		;(* only check first byte *)
B536: CD F5 B1                  	CALL	CKFILPOS	;none?
B539: E1                        	POP	HL
B53A: 22 43 AF                  	LD	(PARAMS),HL	;restore original fcb address.
B53D: C8                        	RET	Z		;return if no more space.
B53E: EB                        	EX	DE,HL
B53F: 21 0F 00                  	LD	HL,15		;point to number of records for this file.
B542: 19                        	ADD	HL,DE
B543: 0E 11                     	LD	C,17		;and clear all of this space.
B545: AF                        	XOR	A
B546: 77                        GETMT1:	LD	(HL),A
B547: 23                        	INC	HL
B548: 0D                        	DEC	C
B549: C2 46 B5                  	JP	NZ,GETMT1
B54C: 21 0D 00                  	LD	HL,13		;clear the 's1' byte also.
B54F: 19                        	ADD	HL,DE
B550: 77                        	LD	(HL),A
B551: CD 8C B1                  	CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
B554: CD FD B3                  	CALL	FCBSET		;write out this fcb entry to directory.
B557: C3 78 B1                  	JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
                                ;
                                ;   Routine to close the current extent and open the next one
                                ; for reading.
                                ;
B55A: AF                        GETNEXT:XOR	A
B55B: 32 D2 B9                  	LD	(CLOSEFLG),A	;clear close flag.
B55E: CD A2 B4                  	CALL	CLOSEIT		;close this extent.
B561: CD F5 B1                  	CALL	CKFILPOS
B564: C8                        	RET	Z		;not there???
B565: 2A 43 AF                  	LD	HL,(PARAMS)	;get extent byte.
B568: 01 0C 00                  	LD	BC,12
B56B: 09                        	ADD	HL,BC
B56C: 7E                        	LD	A,(HL)		;and increment it.
B56D: 3C                        	INC	A
B56E: E6 1F                     	AND	1FH		;keep within range 0-31.
B570: 77                        	LD	(HL),A
B571: CA 83 B5                  	JP	Z,GTNEXT1	;overflow?
B574: 47                        	LD	B,A		;mask extent byte.
B575: 3A C5 B9                  	LD	A,(EXTMASK)
B578: A0                        	AND	B
B579: 21 D2 B9                  	LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
B57C: A6                        	AND	(HL)
B57D: CA 8E B5                  	JP	Z,GTNEXT2	;if zero, we must read in next extent.
B580: C3 AC B5                  	JP	GTNEXT3		;else, it is already in memory.
B583: 01 02 00                  GTNEXT1:LD	BC,2		;Point to the 's2' byte.
B586: 09                        	ADD	HL,BC
B587: 34                        	INC	(HL)		;and bump it.
B588: 7E                        	LD	A,(HL)		;too many extents?
B589: E6 0F                     	AND	0FH
B58B: CA B6 B5                  	JP	Z,GTNEXT5	;yes, set error code.
                                ;
                                ;   Get here to open the next extent.
                                ;
B58E: 0E 0F                     GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
B590: CD 18 B3                  	CALL	FINDFST		;find the first one.
B593: CD F5 B1                  	CALL	CKFILPOS	;none available?
B596: C2 AC B5                  	JP	NZ,GTNEXT3
B599: 3A D3 B9                  	LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
B59C: 3C                        	INC	A		;0ffh means reading (so not possible).
B59D: CA B6 B5                  	JP	Z,GTNEXT5	;or an error.
B5A0: CD 24 B5                  	CALL	GETEMPTY	;we are writing, get an empty entry.
B5A3: CD F5 B1                  	CALL	CKFILPOS	;none?
B5A6: CA B6 B5                  	JP	Z,GTNEXT5	;error if true.
B5A9: C3 AF B5                  	JP	GTNEXT4		;else we are almost done.
B5AC: CD 5A B4                  GTNEXT3:CALL	OPENIT1		;open this extent.
B5AF: CD BB B0                  GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
B5B2: AF                        	XOR	A		;clear status and return.
B5B3: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;   Error in extending the file. Too many extents were needed
                                ; or not enough space on the disk.
                                ;
B5B6: CD 05 AF                  GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
B5B9: C3 78 B1                  	JP	SETS2B7		;so this is not written on a close.
                                ;
                                ;   Read a sequential file.
                                ;
B5BC: 3E 01                     RDSEQ:	LD	A,1		;set sequential access mode.
B5BE: 32 D5 B9                  	LD	(MODE),A
B5C1: 3E FF                     RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
B5C3: 32 D3 B9                  	LD	(RDWRTFLG),A
B5C6: CD BB B0                  	CALL	STRDATA		;put rec# and ext# into fcb.
B5C9: 3A E3 B9                  	LD	A,(SAVNREC)	;get next record to read.
B5CC: 21 E1 B9                  	LD	HL,SAVNXT	;get number of records in extent.
B5CF: BE                        	CP	(HL)		;within this extent?
B5D0: DA E6 B5                  	JP	C,RDSEQ2
B5D3: FE 80                     	CP	128		;no. Is this extent fully used?
B5D5: C2 FB B5                  	JP	NZ,RDSEQ3	;no. End-of-file.
B5D8: CD 5A B5                  	CALL	GETNEXT		;yes, open the next one.
B5DB: AF                        	XOR	A		;reset next record to read.
B5DC: 32 E3 B9                  	LD	(SAVNREC),A
B5DF: 3A 45 AF                  	LD	A,(STATUS)	;check on open, successful?
B5E2: B7                        	OR	A
B5E3: C2 FB B5                  	JP	NZ,RDSEQ3	;no, error.
B5E6: CD 77 B0                  RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
B5E9: CD 84 B0                  	CALL	CHKBLK		;check it. Within bounds?
B5EC: CA FB B5                  	JP	Z,RDSEQ3	;no, error.
B5EF: CD 8A B0                  	CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
B5F2: CD D1 AF                  	CALL	TRKSEC1		;set the track and sector for this block #.
B5F5: CD B2 AF                  	CALL	DOREAD		;and read it.
B5F8: C3 D2 B0                  	JP	SETNREC		;and set the next record to be accessed.
                                ;
                                ;   Read error occured. Set status and return.
                                ;
B5FB: C3 05 AF                  RDSEQ3:	JP	IOERR1
                                ;
                                ;   Write the next sequential record.
                                ;
B5FE: 3E 01                     WTSEQ:	LD	A,1		;set sequential access mode.
B600: 32 D5 B9                  	LD	(MODE),A
B603: 3E 00                     WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
B605: 32 D3 B9                  	LD	(RDWRTFLG),A
B608: CD 54 B1                  	CALL	CHKWPRT		;check write protect status.
B60B: 2A 43 AF                  	LD	HL,(PARAMS)
B60E: CD 47 B1                  	CALL	CKROF1		;check for read only file, (HL) already set to fcb.
B611: CD BB B0                  	CALL	STRDATA		;put updated data into fcb.
B614: 3A E3 B9                  	LD	A,(SAVNREC)	;get record number to write.
B617: FE 80                     	CP	128		;within range?
B619: D2 05 AF                  	JP	NC,IOERR1	;no, error(?).
B61C: CD 77 B0                  	CALL	COMBLK		;compute block number.
B61F: CD 84 B0                  	CALL	CHKBLK		;check number.
B622: 0E 00                     	LD	C,0		;is there one to write to?
B624: C2 6E B6                  	JP	NZ,WTSEQ6	;yes, go do it.
B627: CD 3E B0                  	CALL	GETBLOCK	;get next block number within fcb to use.
B62A: 32 D7 B9                  	LD	(RELBLOCK),A	;and save.
B62D: 01 00 00                  	LD	BC,0		;start looking for space from the start
B630: B7                        	OR	A		;if none allocated as yet.
B631: CA 3B B6                  	JP	Z,WTSEQ2
B634: 4F                        	LD	C,A		;extract previous block number from fcb
B635: 0B                        	DEC	BC		;so we can be closest to it.
B636: CD 5E B0                  	CALL	EXTBLK
B639: 44                        	LD	B,H
B63A: 4D                        	LD	C,L
B63B: CD BE B3                  WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
B63E: 7D                        	LD	A,L		;check for a zero number.
B63F: B4                        	OR	H
B640: C2 48 B6                  	JP	NZ,WTSEQ3
B643: 3E 02                     	LD	A,2		;no more space?
B645: C3 01 AF                  	JP	SETSTAT
B648: 22 E5 B9                  WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
B64B: EB                        	EX	DE,HL		;put block number into (DE).
B64C: 2A 43 AF                  	LD	HL,(PARAMS)	;now we must update the fcb for this
B64F: 01 10 00                  	LD	BC,16		;newly allocated block.
B652: 09                        	ADD	HL,BC
B653: 3A DD B9                  	LD	A,(BIGDISK)	;8 or 16 bit block numbers?
B656: B7                        	OR	A
B657: 3A D7 B9                  	LD	A,(RELBLOCK)	;(* update this entry *)
B65A: CA 64 B6                  	JP	Z,WTSEQ4	;zero means 16 bit ones.
B65D: CD 64 B1                  	CALL	ADDA2HL		;(HL)=(HL)+(A)
B660: 73                        	LD	(HL),E		;store new block number.
B661: C3 6C B6                  	JP	WTSEQ5
B664: 4F                        WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
B665: 06 00                     	LD	B,0
B667: 09                        	ADD	HL,BC
B668: 09                        	ADD	HL,BC
B669: 73                        	LD	(HL),E		;stuff block number (DE) there.
B66A: 23                        	INC	HL
B66B: 72                        	LD	(HL),D
B66C: 0E 02                     WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
B66E: 3A 45 AF                  WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
B671: B7                        	OR	A
B672: C0                        	RET	NZ
B673: C5                        	PUSH	BC		;yes, save write flag for bios (register C).
B674: CD 8A B0                  	CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
B677: 3A D5 B9                  	LD	A,(MODE)	;get access mode flag (1=sequential,
B67A: 3D                        	DEC	A		;0=random, 2=special?).
B67B: 3D                        	DEC	A
B67C: C2 BB B6                  	JP	NZ,WTSEQ9
                                ;
                                ;   Special random i/o from function #40. Maybe for M/PM, but the
                                ; current block, if it has not been written to, will be zeroed
                                ; out and then written (reason?).
                                ;
B67F: C1                        	POP	BC
B680: C5                        	PUSH	BC
B681: 79                        	LD	A,C		;get write status flag (2=writing unused space).
B682: 3D                        	DEC	A
B683: 3D                        	DEC	A
B684: C2 BB B6                  	JP	NZ,WTSEQ9
B687: E5                        	PUSH	HL
B688: 2A B9 B9                  	LD	HL,(DIRBUF)	;zero out the directory buffer.
B68B: 57                        	LD	D,A		;note that (A) is zero here.
B68C: 77                        WTSEQ7:	LD	(HL),A
B68D: 23                        	INC	HL
B68E: 14                        	INC	D		;do 128 bytes.
B68F: F2 8C B6                  	JP	P,WTSEQ7
B692: CD E0 B1                  	CALL	DIRDMA		;tell the bios the dma address for directory access.
B695: 2A E7 B9                  	LD	HL,(LOGSECT)	;get sector that starts current block.
B698: 0E 02                     	LD	C,2		;set 'writing to unused space' flag.
B69A: 22 E5 B9                  WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
B69D: C5                        	PUSH	BC
B69E: CD D1 AF                  	CALL	TRKSEC1		;determine its track and sector numbers.
B6A1: C1                        	POP	BC
B6A2: CD B8 AF                  	CALL	DOWRITE		;now write out 128 bytes of zeros.
B6A5: 2A E5 B9                  	LD	HL,(BLKNMBR)	;get sector number.
B6A8: 0E 00                     	LD	C,0		;set normal write flag.
B6AA: 3A C4 B9                  	LD	A,(BLKMASK)	;determine if we have written the entire
B6AD: 47                        	LD	B,A		;physical block.
B6AE: A5                        	AND	L
B6AF: B8                        	CP	B
B6B0: 23                        	INC	HL		;prepare for the next one.
B6B1: C2 9A B6                  	JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
B6B4: E1                        	POP	HL		;reset next sector number.
B6B5: 22 E5 B9                  	LD	(BLKNMBR),HL
B6B8: CD DA B1                  	CALL	DEFDMA		;and reset dma address.
                                ;
                                ;   Normal disk write. Set the desired track and sector then
                                ; do the actual write.
                                ;
B6BB: CD D1 AF                  WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
B6BE: C1                        	POP	BC		;get write status flag.
B6BF: C5                        	PUSH	BC
B6C0: CD B8 AF                  	CALL	DOWRITE		;and write this out.
B6C3: C1                        	POP	BC
B6C4: 3A E3 B9                  	LD	A,(SAVNREC)	;get number of records in file.
B6C7: 21 E1 B9                  	LD	HL,SAVNXT	;get last record written.
B6CA: BE                        	CP	(HL)
B6CB: DA D2 B6                  	JP	C,WTSEQ10
B6CE: 77                        	LD	(HL),A		;we have to update record count.
B6CF: 34                        	INC	(HL)
B6D0: 0E 02                     	LD	C,2
                                ;
                                ;*   This area has been patched to correct disk update problem
                                ;* when using blocking and de-blocking in the BIOS.
                                ;
B6D2: 00                        WTSEQ10:NOP			;was 'dcr c'
B6D3: 00                        	NOP			;was 'dcr c'
B6D4: 21 00 00                  	LD	HL,0		;was 'jnz wtseq99'
                                ;
                                ; *   End of patch.
                                ;
B6D7: F5                        	PUSH	AF
B6D8: CD 69 B1                  	CALL	GETS2		;set 'extent written to' flag.
B6DB: E6 7F                     	AND	7FH		;(* clear bit 7 *)
B6DD: 77                        	LD	(HL),A
B6DE: F1                        	POP	AF		;get record count for this extent.
B6DF: FE 7F                     WTSEQ99:CP	127		;is it full?
B6E1: C2 00 B7                  	JP	NZ,WTSEQ12
B6E4: 3A D5 B9                  	LD	A,(MODE)	;yes, are we in sequential mode?
B6E7: FE 01                     	CP	1
B6E9: C2 00 B7                  	JP	NZ,WTSEQ12
B6EC: CD D2 B0                  	CALL	SETNREC		;yes, set next record number.
B6EF: CD 5A B5                  	CALL	GETNEXT		;and get next empty space in directory.
B6F2: 21 45 AF                  	LD	HL,STATUS	;ok?
B6F5: 7E                        	LD	A,(HL)
B6F6: B7                        	OR	A
B6F7: C2 FE B6                  	JP	NZ,WTSEQ11
B6FA: 3D                        	DEC	A		;yes, set record count to -1.
B6FB: 32 E3 B9                  	LD	(SAVNREC),A
B6FE: 36 00                     WTSEQ11:LD	(HL),0		;clear status.
B700: C3 D2 B0                  WTSEQ12:JP	SETNREC		;set next record to access.
                                ;
                                ;   For random i/o, set the fcb for the desired record number
                                ; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
                                ; used as follows:
                                ;
                                ;       fcb+35            fcb+34            fcb+33
                                ;  |     'r-2'      |      'r-1'      |      'r-0'     |
                                ;  |7             0 | 7             0 | 7             0|
                                ;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
                                ;  |    overflow   | | extra |  extent   |   record #  |
                                ;  | ______________| |_extent|__number___|_____________|
                                ;                     also 's2'
                                ;
                                ;   On entry, register (C) contains 0ffh if this is a read
                                ; and thus we can not access unwritten disk space. Otherwise,
                                ; another extent will be opened (for writing) if required.
                                ;
B703: AF                        POSITION: XOR	A		;set random i/o flag.
B704: 32 D5 B9                  	LD	(MODE),A
                                ;
                                ;   Special entry (function #40). M/PM ?
                                ;
B707: C5                        POSITN1:PUSH	BC		;save read/write flag.
B708: 2A 43 AF                  	LD	HL,(PARAMS)	;get address of fcb.
B70B: EB                        	EX	DE,HL
B70C: 21 21 00                  	LD	HL,33		;now get byte 'r0'.
B70F: 19                        	ADD	HL,DE
B710: 7E                        	LD	A,(HL)
B711: E6 7F                     	AND	7FH		;keep bits 0-6 for the record number to access.
B713: F5                        	PUSH	AF
B714: 7E                        	LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
B715: 17                        	RLA	
B716: 23                        	INC	HL
B717: 7E                        	LD	A,(HL)
B718: 17                        	RLA	
B719: E6 1F                     	AND	1FH		;and save this in bits 0-4 of (C).
B71B: 4F                        	LD	C,A		;this is the extent byte.
B71C: 7E                        	LD	A,(HL)		;now get the extra extent byte.
B71D: 1F                        	RRA	
B71E: 1F                        	RRA	
B71F: 1F                        	RRA	
B720: 1F                        	RRA	
B721: E6 0F                     	AND	0FH
B723: 47                        	LD	B,A		;and save it in (B).
B724: F1                        	POP	AF		;get record number back to (A).
B725: 23                        	INC	HL		;check overflow byte 'r2'.
B726: 6E                        	LD	L,(HL)
B727: 2C                        	INC	L
B728: 2D                        	DEC	L
B729: 2E 06                     	LD	L,6		;prepare for error.
B72B: C2 8B B7                  	JP	NZ,POSITN5	;out of disk space error.
B72E: 21 20 00                  	LD	HL,32		;store record number into fcb.
B731: 19                        	ADD	HL,DE
B732: 77                        	LD	(HL),A
B733: 21 0C 00                  	LD	HL,12		;and now check the extent byte.
B736: 19                        	ADD	HL,DE
B737: 79                        	LD	A,C
B738: 96                        	SUB	(HL)		;same extent as before?
B739: C2 47 B7                  	JP	NZ,POSITN2
B73C: 21 0E 00                  	LD	HL,14		;yes, check extra extent byte 's2' also.
B73F: 19                        	ADD	HL,DE
B740: 78                        	LD	A,B
B741: 96                        	SUB	(HL)
B742: E6 7F                     	AND	7FH
B744: CA 7F B7                  	JP	Z,POSITN3	;same, we are almost done then.
                                ;
                                ;  Get here when another extent is required.
                                ;
B747: C5                        POSITN2:PUSH	BC
B748: D5                        	PUSH	DE
B749: CD A2 B4                  	CALL	CLOSEIT		;close current extent.
B74C: D1                        	POP	DE
B74D: C1                        	POP	BC
B74E: 2E 03                     	LD	L,3		;prepare for error.
B750: 3A 45 AF                  	LD	A,(STATUS)
B753: 3C                        	INC	A
B754: CA 84 B7                  	JP	Z,POSITN4	;close error.
B757: 21 0C 00                  	LD	HL,12		;put desired extent into fcb now.
B75A: 19                        	ADD	HL,DE
B75B: 71                        	LD	(HL),C
B75C: 21 0E 00                  	LD	HL,14		;and store extra extent byte 's2'.
B75F: 19                        	ADD	HL,DE
B760: 70                        	LD	(HL),B
B761: CD 51 B4                  	CALL	OPENIT		;try and get this extent.
B764: 3A 45 AF                  	LD	A,(STATUS)	;was it there?
B767: 3C                        	INC	A
B768: C2 7F B7                  	JP	NZ,POSITN3
B76B: C1                        	POP	BC		;no. can we create a new one (writing?).
B76C: C5                        	PUSH	BC
B76D: 2E 04                     	LD	L,4		;prepare for error.
B76F: 0C                        	INC	C
B770: CA 84 B7                  	JP	Z,POSITN4	;nope, reading unwritten space error.
B773: CD 24 B5                  	CALL	GETEMPTY	;yes we can, try to find space.
B776: 2E 05                     	LD	L,5		;prepare for error.
B778: 3A 45 AF                  	LD	A,(STATUS)
B77B: 3C                        	INC	A
B77C: CA 84 B7                  	JP	Z,POSITN4	;out of space?
                                ;
                                ;   Normal return location. Clear error code and return.
                                ;
B77F: C1                        POSITN3:POP	BC		;restore stack.
B780: AF                        	XOR	A		;and clear error code byte.
B781: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;   Error. Set the 's2' byte to indicate this (why?).
                                ;
B784: E5                        POSITN4:PUSH	HL
B785: CD 69 B1                  	CALL	GETS2
B788: 36 C0                     	LD	(HL),0C0H
B78A: E1                        	POP	HL
                                ;
                                ;   Return with error code (presently in L).
                                ;
B78B: C1                        POSITN5:POP	BC
B78C: 7D                        	LD	A,L		;get error code.
B78D: 32 45 AF                  	LD	(STATUS),A
B790: C3 78 B1                  	JP	SETS2B7
                                ;
                                ;   Read a random record.
                                ;
B793: 0E FF                     READRAN:LD	C,0FFH		;set 'read' status.
B795: CD 03 B7                  	CALL	POSITION	;position the file to proper record.
B798: CC C1 B5                  	CALL	Z,RDSEQ1	;and read it as usual (if no errors).
B79B: C9                        	RET	
                                ;
                                ;   Write to a random record.
                                ;
B79C: 0E 00                     WRITERAN: LD	C,0		;set 'writing' flag.
B79E: CD 03 B7                  	CALL	POSITION	;position the file to proper record.
B7A1: CC 03 B6                  	CALL	Z,WTSEQ1	;and write as usual (if no errors).
B7A4: C9                        	RET	
                                ;
                                ;   Compute the random record number. Enter with (HL) pointing
                                ; to a fcb an (DE) contains a relative location of a record
                                ; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
                                ; byte, and (A) the 'r2' byte.
                                ;
                                ;   On return, the zero flag is set if the record is within
                                ; bounds. Otherwise, an overflow occured.
                                ;
B7A5: EB                        COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
B7A6: 19                        	ADD	HL,DE		;compute relative position of record #.
B7A7: 4E                        	LD	C,(HL)		;get record number into (BC).
B7A8: 06 00                     	LD	B,0
B7AA: 21 0C 00                  	LD	HL,12		;now get extent.
B7AD: 19                        	ADD	HL,DE
B7AE: 7E                        	LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
B7AF: 0F                        	RRCA			;move lower bit into bit 7.
B7B0: E6 80                     	AND	80H		;and ignore all other bits.
B7B2: 81                        	ADD	A,C		;add to our record number.
B7B3: 4F                        	LD	C,A
B7B4: 3E 00                     	LD	A,0		;take care of any carry.
B7B6: 88                        	ADC	A,B
B7B7: 47                        	LD	B,A
B7B8: 7E                        	LD	A,(HL)		;now get the upper bits of extent into
B7B9: 0F                        	RRCA			;bit positions 0-3.
B7BA: E6 0F                     	AND	0FH		;and ignore all others.
B7BC: 80                        	ADD	A,B		;add this in to 'r1' byte.
B7BD: 47                        	LD	B,A
B7BE: 21 0E 00                  	LD	HL,14		;get the 's2' byte (extra extent).
B7C1: 19                        	ADD	HL,DE
B7C2: 7E                        	LD	A,(HL)
B7C3: 87                        	ADD	A,A		;and shift it left 4 bits (bits 4-7).
B7C4: 87                        	ADD	A,A
B7C5: 87                        	ADD	A,A
B7C6: 87                        	ADD	A,A
B7C7: F5                        	PUSH	AF		;save carry flag (bit 0 of flag byte).
B7C8: 80                        	ADD	A,B		;now add extra extent into 'r1'.
B7C9: 47                        	LD	B,A
B7CA: F5                        	PUSH	AF		;and save carry (overflow byte 'r2').
B7CB: E1                        	POP	HL		;bit 0 of (L) is the overflow indicator.
B7CC: 7D                        	LD	A,L
B7CD: E1                        	POP	HL		;and same for first carry flag.
B7CE: B5                        	OR	L		;either one of these set?
B7CF: E6 01                     	AND	01H		;only check the carry flags.
B7D1: C9                        	RET	
                                ;
                                ;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
                                ; reflect the last record used for a random (or other) file.
                                ; This reads the directory and looks at all extents computing
                                ; the largerst record number for each and keeping the maximum
                                ; value only. Then 'r0', 'r1', and 'r2' will reflect this
                                ; maximum record number. This is used to compute the space used
                                ; by a random file.
                                ;
B7D2: 0E 0C                     RANSIZE:LD	C,12		;look thru directory for first entry with
B7D4: CD 18 B3                  	CALL	FINDFST		;this name.
B7D7: 2A 43 AF                  	LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
B7DA: 11 21 00                  	LD	DE,33
B7DD: 19                        	ADD	HL,DE
B7DE: E5                        	PUSH	HL
B7DF: 72                        	LD	(HL),D		;note that (D)=0.
B7E0: 23                        	INC	HL
B7E1: 72                        	LD	(HL),D
B7E2: 23                        	INC	HL
B7E3: 72                        	LD	(HL),D
B7E4: CD F5 B1                  RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
B7E7: CA 0C B8                  	JP	Z,RANSIZ3	;no, we are done.
B7EA: CD 5E B1                  	CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
B7ED: 11 0F 00                  	LD	DE,15		;point to last record in extent.
B7F0: CD A5 B7                  	CALL	COMPRAND	;and compute random parameters.
B7F3: E1                        	POP	HL
B7F4: E5                        	PUSH	HL		;now check these values against those
B7F5: 5F                        	LD	E,A		;already in fcb.
B7F6: 79                        	LD	A,C		;the carry flag will be set if those
B7F7: 96                        	SUB	(HL)		;in the fcb represent a larger size than
B7F8: 23                        	INC	HL		;this extent does.
B7F9: 78                        	LD	A,B
B7FA: 9E                        	SBC	A,(HL)
B7FB: 23                        	INC	HL
B7FC: 7B                        	LD	A,E
B7FD: 9E                        	SBC	A,(HL)
B7FE: DA 06 B8                  	JP	C,RANSIZ2
B801: 73                        	LD	(HL),E		;we found a larger (in size) extent.
B802: 2B                        	DEC	HL		;stuff these values into fcb.
B803: 70                        	LD	(HL),B
B804: 2B                        	DEC	HL
B805: 71                        	LD	(HL),C
B806: CD 2D B3                  RANSIZ2:CALL	FINDNXT		;now get the next extent.
B809: C3 E4 B7                  	JP	RANSIZ1		;continue til all done.
B80C: E1                        RANSIZ3:POP	HL		;we are done, restore the stack and
B80D: C9                        	RET			;return.
                                ;
                                ;   Function to return the random record position of a given
                                ; file which has been read in sequential mode up to now.
                                ;
B80E: 2A 43 AF                  SETRAN:	LD	HL,(PARAMS)	;point to fcb.
B811: 11 20 00                  	LD	DE,32		;and to last used record.
B814: CD A5 B7                  	CALL	COMPRAND	;compute random position.
B817: 21 21 00                  	LD	HL,33		;now stuff these values into fcb.
B81A: 19                        	ADD	HL,DE
B81B: 71                        	LD	(HL),C		;move 'r0'.
B81C: 23                        	INC	HL
B81D: 70                        	LD	(HL),B		;and 'r1'.
B81E: 23                        	INC	HL
B81F: 77                        	LD	(HL),A		;and lastly 'r2'.
B820: C9                        	RET	
                                ;
                                ;   This routine select the drive specified in (ACTIVE) and
                                ; update the login vector and bitmap table if this drive was
                                ; not already active.
                                ;
B821: 2A AF B9                  LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
B824: 3A 42 AF                  	LD	A,(ACTIVE)	;get the default drive.
B827: 4F                        	LD	C,A
B828: CD EA B0                  	CALL	SHIFTR		;position active bit for this drive
B82B: E5                        	PUSH	HL		;into bit 0.
B82C: EB                        	EX	DE,HL
B82D: CD 59 AF                  	CALL	SELECT		;select this drive.
B830: E1                        	POP	HL
B831: CC 47 AF                  	CALL	Z,SLCTERR	;valid drive?
B834: 7D                        	LD	A,L		;is this a newly activated drive?
B835: 1F                        	RRA	
B836: D8                        	RET	C
B837: 2A AF B9                  	LD	HL,(LOGIN)	;yes, update the login vector.
B83A: 4D                        	LD	C,L
B83B: 44                        	LD	B,H
B83C: CD 0B B1                  	CALL	SETBIT
B83F: 22 AF B9                  	LD	(LOGIN),HL	;and save.
B842: C3 A3 B2                  	JP	BITMAAP		;now update the bitmap.
                                ;
                                ;   Function to set the active disk number.
                                ;
B845: 3A D6 B9                  SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
B848: 21 42 AF                  	LD	HL,ACTIVE	;represents a change in drives.
B84B: BE                        	CP	(HL)
B84C: C8                        	RET	Z
B84D: 77                        	LD	(HL),A		;yes it does, log it in.
B84E: C3 21 B8                  	JP	LOGINDRV
                                ;
                                ;   This is the 'auto disk select' routine. The firsst byte
                                ; of the fcb is examined for a drive specification. If non
                                ; zero then the drive will be selected and loged in.
                                ;
B851: 3E FF                     AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
B853: 32 DE B9                  	LD	(AUTO),A
B856: 2A 43 AF                  	LD	HL,(PARAMS)	;get drive specified.
B859: 7E                        	LD	A,(HL)
B85A: E6 1F                     	AND	1FH		;look at lower 5 bits.
B85C: 3D                        	DEC	A		;adjust for (1=A, 2=B) etc.
B85D: 32 D6 B9                  	LD	(EPARAM),A	;and save for the select routine.
B860: FE 1E                     	CP	1EH		;check for 'no change' condition.
B862: D2 75 B8                  	JP	NC,AUTOSL1	;yes, don't change.
B865: 3A 42 AF                  	LD	A,(ACTIVE)	;we must change, save currently active
B868: 32 DF B9                  	LD	(OLDDRV),A	;drive.
B86B: 7E                        	LD	A,(HL)		;and save first byte of fcb also.
B86C: 32 E0 B9                  	LD	(AUTOFLAG),A	;this must be non-zero.
B86F: E6 E0                     	AND	0E0H		;whats this for (bits 6,7 are used for
B871: 77                        	LD	(HL),A		;something)?
B872: CD 45 B8                  	CALL	SETDSK		;select and log in this drive.
B875: 3A 41 AF                  AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
B878: 2A 43 AF                  	LD	HL,(PARAMS)	;(* upper half of first byte *)
B87B: B6                        	OR	(HL)
B87C: 77                        	LD	(HL),A
B87D: C9                        	RET			;and return (all done).
                                ;
                                ;   Function to return the current cp/m version number.
                                ;
B87E: 3E 22                     GETVER:	LD	A,022H		;version 2.2
B880: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;   Function to reset the disk system.
                                ;
B883: 21 00 00                  RSTDSK:	LD	HL,0		;clear write protect status and log
B886: 22 AD B9                  	LD	(WRTPRT),HL	;in vector.
B889: 22 AF B9                  	LD	(LOGIN),HL
B88C: AF                        	XOR	A		;select drive 'A'.
B88D: 32 42 AF                  	LD	(ACTIVE),A
B890: 21 80 00                  	LD	HL,TBUFF	;setup default dma address.
B893: 22 B1 B9                  	LD	(USERDMA),HL
B896: CD DA B1                  	CALL	DEFDMA
B899: C3 21 B8                  	JP	LOGINDRV	;now log in drive 'A'.
                                ;
                                ;   Function to open a specified file.
                                ;
B89C: CD 72 B1                  OPENFIL:CALL	CLEARS2		;clear 's2' byte.
B89F: CD 51 B8                  	CALL	AUTOSEL		;select proper disk.
B8A2: C3 51 B4                  	JP	OPENIT		;and open the file.
                                ;
                                ;   Function to close a specified file.
                                ;
B8A5: CD 51 B8                  CLOSEFIL: CALL	AUTOSEL		;select proper disk.
B8A8: C3 A2 B4                  	JP	CLOSEIT		;and close the file.
                                ;
                                ;   Function to return the first occurence of a specified file
                                ; name. If the first byte of the fcb is '?' then the name will
                                ; not be checked (get the first entry no matter what).
                                ;
B8AB: 0E 00                     GETFST:	LD	C,0		;prepare for special search.
B8AD: EB                        	EX	DE,HL
B8AE: 7E                        	LD	A,(HL)		;is first byte a '?'?
B8AF: FE 3F                     	CP	'?'
B8B1: CA C2 B8                  	JP	Z,GETFST1	;yes, just get very first entry (zero length match).
B8B4: CD A6 B0                  	CALL	SETEXT		;get the extension byte from fcb.
B8B7: 7E                        	LD	A,(HL)		;is it '?'? if yes, then we want
B8B8: FE 3F                     	CP	'?'		;an entry with a specific 's2' byte.
B8BA: C4 72 B1                  	CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
B8BD: CD 51 B8                  	CALL	AUTOSEL		;select proper drive.
B8C0: 0E 0F                     	LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
B8C2: CD 18 B3                  GETFST1:CALL	FINDFST		;find an entry and then move it into
B8C5: C3 E9 B1                  	JP	MOVEDIR		;the users dma space.
                                ;
                                ;   Function to return the next occurence of a file name.
                                ;
B8C8: 2A D9 B9                  GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
B8CB: 22 43 AF                  	LD	(PARAMS),HL	;other dbos calls are allowed.
B8CE: CD 51 B8                  	CALL	AUTOSEL		;no error will be returned, but the
B8D1: CD 2D B3                  	CALL	FINDNXT		;results will be wrong.
B8D4: C3 E9 B1                  	JP	MOVEDIR
                                ;
                                ;   Function to delete a file by name.
                                ;
B8D7: CD 51 B8                  DELFILE:CALL	AUTOSEL		;select proper drive.
B8DA: CD 9C B3                  	CALL	ERAFILE		;erase the file.
B8DD: C3 01 B3                  	JP	STSTATUS	;set status and return.
                                ;
                                ;   Function to execute a sequential read of the specified
                                ; record number.
                                ;
B8E0: CD 51 B8                  READSEQ:CALL	AUTOSEL		;select proper drive then read.
B8E3: C3 BC B5                  	JP	RDSEQ
                                ;
                                ;   Function to write the net sequential record.
                                ;
B8E6: CD 51 B8                  WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
B8E9: C3 FE B5                  	JP	WTSEQ
                                ;
                                ;   Create a file function.
                                ;
B8EC: CD 72 B1                  FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
B8EF: CD 51 B8                  	CALL	AUTOSEL		;select proper drive and get the next
B8F2: C3 24 B5                  	JP	GETEMPTY	;empty directory space.
                                ;
                                ;   Function to rename a file.
                                ;
B8F5: CD 51 B8                  RENFILE:CALL	AUTOSEL		;select proper drive and then switch
B8F8: CD 16 B4                  	CALL	CHGNAMES	;file names.
B8FB: C3 01 B3                  	JP	STSTATUS
                                ;
                                ;   Function to return the login vector.
                                ;
B8FE: 2A AF B9                  GETLOG:	LD	HL,(LOGIN)
B901: C3 29 B9                  	JP	GETPRM1
                                ;
                                ;   Function to return the current disk assignment.
                                ;
B904: 3A 42 AF                  GETCRNT:LD	A,(ACTIVE)
B907: C3 01 AF                  	JP	SETSTAT
                                ;
                                ;   Function to set the dma address.
                                ;
B90A: EB                        PUTDMA:	EX	DE,HL
B90B: 22 B1 B9                  	LD	(USERDMA),HL	;save in our space and then get to
B90E: C3 DA B1                  	JP	DEFDMA		;the bios with this also.
                                ;
                                ;   Function to return the allocation vector.
                                ;
B911: 2A BF B9                  GETALOC:LD	HL,(ALOCVECT)
B914: C3 29 B9                  	JP	GETPRM1
                                ;
                                ;   Function to return the read-only status vector.
                                ;
B917: 2A AD B9                  GETROV:	LD	HL,(WRTPRT)
B91A: C3 29 B9                  	JP	GETPRM1
                                ;
                                ;   Function to set the file attributes (read-only, system).
                                ;
B91D: CD 51 B8                  SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
B920: CD 3B B4                  	CALL	SAVEATTR
B923: C3 01 B3                  	JP	STSTATUS
                                ;
                                ;   Function to return the address of the disk parameter block
                                ; for the current drive.
                                ;
B926: 2A BB B9                  GETPARM:LD	HL,(DISKPB)
B929: 22 45 AF                  GETPRM1:LD	(STATUS),HL
B92C: C9                        	RET	
                                ;
                                ;   Function to get or set the user number. If (E) was (FF)
                                ; then this is a request to return the current user number.
                                ; Else set the user number from (E).
                                ;
B92D: 3A D6 B9                  GETUSER:LD	A,(EPARAM)	;get parameter.
B930: FE FF                     	CP	0FFH		;get user number?
B932: C2 3B B9                  	JP	NZ,SETUSER
B935: 3A 41 AF                  	LD	A,(USERNO)	;yes, just do it.
B938: C3 01 AF                  	JP	SETSTAT
B93B: E6 1F                     SETUSER:AND	1FH		;no, we should set it instead. keep low
B93D: 32 41 AF                  	LD	(USERNO),A	;bits (0-4) only.
B940: C9                        	RET	
                                ;
                                ;   Function to read a random record from a file.
                                ;
B941: CD 51 B8                  RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
B944: C3 93 B7                  	JP	READRAN
                                ;
                                ;   Function to compute the file size for random files.
                                ;
B947: CD 51 B8                  WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
B94A: C3 9C B7                  	JP	WRITERAN
                                ;
                                ;   Function to compute the size of a random file.
                                ;
B94D: CD 51 B8                  FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
B950: C3 D2 B7                  	JP	RANSIZE
                                ;
                                ;   Function #37. This allows a program to log off any drives.
                                ; On entry, set (DE) to contain a word with bits set for those
                                ; drives that are to be logged off. The log-in vector and the
                                ; write protect vector will be updated. This must be a M/PM
                                ; special function.
                                ;
B953: 2A 43 AF                  LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
B956: 7D                        	LD	A,L		;for each bit that is set, we want
B957: 2F                        	CPL			;to clear that bit in (LOGIN)
B958: 5F                        	LD	E,A		;and (WRTPRT).
B959: 7C                        	LD	A,H
B95A: 2F                        	CPL	
B95B: 2A AF B9                  	LD	HL,(LOGIN)	;reset the login vector.
B95E: A4                        	AND	H
B95F: 57                        	LD	D,A
B960: 7D                        	LD	A,L
B961: A3                        	AND	E
B962: 5F                        	LD	E,A
B963: 2A AD B9                  	LD	HL,(WRTPRT)
B966: EB                        	EX	DE,HL
B967: 22 AF B9                  	LD	(LOGIN),HL	;and save.
B96A: 7D                        	LD	A,L		;now do the write protect vector.
B96B: A3                        	AND	E
B96C: 6F                        	LD	L,A
B96D: 7C                        	LD	A,H
B96E: A2                        	AND	D
B96F: 67                        	LD	H,A
B970: 22 AD B9                  	LD	(WRTPRT),HL	;and save. all done.
B973: C9                        	RET	
                                ;
                                ;   Get here to return to the user.
                                ;
B974: 3A DE B9                  GOBACK:	LD	A,(AUTO)	;was auto select activated?
B977: B7                        	OR	A
B978: CA 91 B9                  	JP	Z,GOBACK1
B97B: 2A 43 AF                  	LD	HL,(PARAMS)	;yes, but was a change made?
B97E: 36 00                     	LD	(HL),0		;(* reset first byte of fcb *)
B980: 3A E0 B9                  	LD	A,(AUTOFLAG)
B983: B7                        	OR	A
B984: CA 91 B9                  	JP	Z,GOBACK1
B987: 77                        	LD	(HL),A		;yes, reset first byte properly.
B988: 3A DF B9                  	LD	A,(OLDDRV)	;and get the old drive and select it.
B98B: 32 D6 B9                  	LD	(EPARAM),A
B98E: CD 45 B8                  	CALL	SETDSK
B991: 2A 0F AF                  GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
B994: F9                        	LD	SP,HL
B995: 2A 45 AF                  	LD	HL,(STATUS)	;get return status.
B998: 7D                        	LD	A,L		;force version 1.4 compatability.
B999: 44                        	LD	B,H
B99A: C9                        	RET			;and go back to user.
                                ;
                                ;   Function #40. This is a special entry to do random i/o.
                                ; For the case where we are writing to unused disk space, this
                                ; space will be zeroed out first. This must be a M/PM special
                                ; purpose function, because why would any normal program even
                                ; care about the previous contents of a sector about to be
                                ; written over.
                                ;
B99B: CD 51 B8                  WTSPECL:CALL	AUTOSEL		;select proper drive.
B99E: 3E 02                     	LD	A,2		;use special write mode.
B9A0: 32 D5 B9                  	LD	(MODE),A
B9A3: 0E 00                     	LD	C,0		;set write indicator.
B9A5: CD 07 B7                  	CALL	POSITN1		;position the file.
B9A8: CC 03 B6                  	CALL	Z,WTSEQ1	;and write (if no errors).
B9AB: C9                        	RET	
                                ;
                                ;**************************************************************
                                ;*
                                ;*     BDOS data storage pool.
                                ;*
                                ;**************************************************************
                                ;
B9AC: E5                        EMPTYFCB: DB	0E5H		;empty directory segment indicator.
B9AD: 00 00                     WRTPRT:	DW	0		;write protect status for all 16 drives.
B9AF: 00 00                     LOGIN:	DW	0		;drive active word (1 bit per drive).
B9B1: 80 00                     USERDMA:DW	080H		;user's dma address (defaults to 80h).
                                ;
                                ;   Scratch areas from parameter block.
                                ;
B9B3: 00 00                     SCRATCH1: DW	0		;relative position within dir segment for file (0-3).
B9B5: 00 00                     SCRATCH2: DW	0		;last selected track number.
B9B7: 00 00                     SCRATCH3: DW	0		;last selected sector number.
                                ;
                                ;   Disk storage areas from parameter block.
                                ;
B9B9: 00 00                     DIRBUF:	DW	0		;address of directory buffer to use.
B9BB: 00 00                     DISKPB:	DW	0		;contains address of disk parameter block.
B9BD: 00 00                     CHKVECT:DW	0		;address of check vector.
B9BF: 00 00                     ALOCVECT: DW	0		;address of allocation vector (bit map).
                                ;
                                ;   Parameter block returned from the bios.
                                ;
B9C1: 00 00                     SECTORS:DW	0		;sectors per track from bios.
B9C3: 00                        BLKSHFT:DB	0		;block shift.
B9C4: 00                        BLKMASK:DB	0		;block mask.
B9C5: 00                        EXTMASK:DB	0		;extent mask.
B9C6: 00 00                     DSKSIZE:DW	0		;disk size from bios (number of blocks-1).
B9C8: 00 00                     DIRSIZE:DW	0		;directory size.
B9CA: 00 00                     ALLOC0:	DW	0		;storage for first bytes of bit map (dir space used).
B9CC: 00 00                     ALLOC1:	DW	0
B9CE: 00 00                     OFFSET:	DW	0		;first usable track number.
B9D0: 00 00                     XLATE:	DW	0		;sector translation table address.
                                ;
                                ;
B9D2: 00                        CLOSEFLG: DB	0		;close flag (=0ffh is extent written ok).
B9D3: 00                        RDWRTFLG: DB	0		;read/write flag (0ffh=read, 0=write).
B9D4: 00                        FNDSTAT:DB	0		;filename found status (0=found first entry).
B9D5: 00                        MODE:	DB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
B9D6: 00                        EPARAM:	DB	0		;storage for register (E) on entry to bdos.
B9D7: 00                        RELBLOCK: DB	0		;relative position within fcb of block number written.
B9D8: 00                        COUNTER:DB	0		;byte counter for directory name searches.
B9D9: 00 00 00 00               SAVEFCB:DW	0,0		;save space for address of fcb (for directory searches).
B9DD: 00                        BIGDISK:DB	0		;if =0 then disk is > 256 blocks long.
B9DE: 00                        AUTO:	DB	0		;if non-zero, then auto select activated.
B9DF: 00                        OLDDRV:	DB	0		;on auto select, storage for previous drive.
B9E0: 00                        AUTOFLAG: DB	0		;if non-zero, then auto select changed drives.
B9E1: 00                        SAVNXT:	DB	0		;storage for next record number to access.
B9E2: 00                        SAVEXT:	DB	0		;storage for extent number of file.
B9E3: 00 00                     SAVNREC:DW	0		;storage for number of records in file.
B9E5: 00 00                     BLKNMBR:DW	0		;block number (physical sector) used within a file or logical sect
B9E7: 00 00                     LOGSECT:DW	0		;starting logical (128 byte) sector of block (physical sector).
B9E9: 00                        FCBPOS:	DB	0		;relative position within buffer for fcb of file of interest.
B9EA: 00 00                     FILEPOS:DW	0		;files position within directory (0 to max entries -1).
                                ;
                                ;   Disk directory buffer checksum bytes. One for each of the
                                ; 16 possible drives.
                                ;
B9EC: 00 00 00 00 00 00 00 00   CKSUMTBL: DB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
B9F4: 00 00 00 00 00 00 00 00 
                                ;
                                ;   Extra space ?
                                ;
B9FC: 00 00 00 00               	DB	0,0,0,0
                                ;
                                ;**************************************************************
                                ;*
                                ;*        B I O S   J U M P   T A B L E
                                ;*
                                ;**************************************************************
                                ;
                                
                                ;BOOT	EQU STARTBIOS +  0*3		;NOTE WE USE FAKE DESTINATIONS
                                ;WBOOT	EQU STARTBIOS +  1*3
                                ;CONST	EQU STARTBIOS +  2*3
                                ;CONIN	EQU STARTBIOS +  3*3
                                ;CONOUT	EQU STARTBIOS +  4*3
                                ;LIST	EQU STARTBIOS +  5*3
                                PUNCH	EQU STARTBIOS +  6*3
                                ;READER	EQU STARTBIOS +  7*3
                                ;HOME	EQU STARTBIOS +  8*3
                                ;SELDSK	EQU STARTBIOS +  9*3
                                ;SETTRK	EQU STARTBIOS + 10*3
                                ;SETSEC	EQU STARTBIOS + 11*3
                                ;SETDMA	EQU STARTBIOS + 12*3
                                ;READ	EQU STARTBIOS + 13*3
                                ;WRITE	EQU STARTBIOS + 14*3
                                PRSTAT	EQU STARTBIOS + 15*3
                                SECTRN	EQU STARTBIOS + 16*3
                                ;
                                ;*
                                ;******************   E N D   O F   C P / M   *****************
                                ;*
                                
                                

                                ---------------------------------

                                include "cbios.asm"

                                ---------------------------------

                                SERIAL    EQU $7A    ; serial port
                                DRIVESEL  EQU $3F    ; selezione drive number e side
                                FDCCMD    EQU $BC    ; 1791 - Comandi/status
                                FDCTRK    EQU $BD    ; 1791 - Traccia
                                FDCSEC    EQU $BE    ; 1791 - Settore
                                FDCDATA   EQU $BF    ; 1791 - Dati
                                
                                SECTORSIZE EQU $80
                                
                                
                                SOMECCPCALL       EQU $AC06   ; installed as JP at address $0005
                                
                                STARTCCP          EQU $A400   ; start of CCP in memory
                                
                                VDDTABLE          EQU $BFE0  ; start of VDD table, usually loaded into IX. Also pointed by VDDPOINTER
                                LAST_TRACK        EQU $BFEC  ; last used track (never written to?)
                                
                                KBDIN             EQU $E3DC   ; keyboard input, puts read key in A
                                EPROM_PRTCHAR     EQU $E403   ; used in some dead code in CBIOS
                                EPROM_INITD       EQU $E800   ; initialize the disk routines
                                EPROM_E650        EQU $E650   ; ?? chiamata dall jump table del CBIOS, legge/scrive su 5Ch/5Dh
                                EPROM_E82A        EQU $E82A   ; used by CBIOS
                                EPROM_SETDRIVE    EQU $E809   ; drive in C
                                EPROM_SETSECTOR   EQU $E806   ; sector in C
                                EPROM_SETDMA      EQU $E80C   ; set DMA buffer at HL, writes also in EPROM_U1, EPROM_U2
                                EPROM_READSECTOR  EQU $E812
                                EPROM_WRITESECTOR EQU $E80F
                                EPROM_SETTRACK    EQU $E803   ; track in C
                                WRSTG             EQU $E3FA    ; prints string in HL until char with 7 bit on
                                
                                ORG STARTBIOS
                                
BA00: C3 12 BB                              jp      BOOT            ;ARRIVE HERE FROM COLD START LOAD
BA03: C3 D1 BA                  WARMBOOT:   jp      WBOOT           ;ARRIVE HERE FOR WARM START
BA06: C3 7B BB                              jp      CONST           ;CHECK FOR CONSOLE CHAR READY
BA09: C3 59 BD                  FCONIN:     jp      CONIN           ;READ CONSOLE CHARACTER IN
BA0C: C3 DE BB                              jp      CONOUT          ;WRITE CONSOLE CHARACTER OUT
BA0F: C3 03 BC                              jp      LIST            ;WRITE LISTING CHARACTER OUT
BA12: C3 03 BC                              jp      LIST            ;WRITE CHARACTER TO PUNCH DEVICE
BA15: C3 C8 BB                              jp      READER          ;READ READER DEVICE
BA18: C3 1D BC                              jp      HOME            ;MOVE TO TRACK 00 ON SELECTED DISK
BA1B: C3 26 BC                              jp      SELDSK          ;SELECT DISK DRIVE
BA1E: C3 3F BC                              jp      SETTRK          ;SET TRACK NUMBER
BA21: C3 44 BC                              jp      SETSEC          ;SET SECTOR NUMBER
BA24: C3 4F BC                              jp      SETDMA          ;SET DMA ADDRESS
BA27: C3 54 BC                              jp      READ            ;READ SELECTED SECTOR
BA2A: C3 63 BC                              jp      WRITE           ;WRITE SELECTED SECTOR
BA2D: C3 A2 BB                              jp      LISTST          ;RETURN LIST STATUS
BA30: C3 49 BC                              jp      SECTRAN         ;SECTOR TRANSLATE SUBROUTINE
BA33: C3 00 00                              jp      0000h
BA36: C3 00 00                              jp      0000h
BA39: C3 00 00                              jp      0000h
BA3C: C3 00 00                              jp      0000h
BA3F: C3 00 00                              jp      0000h
BA42: C3 00 00                              jp      0000h
BA45: C3 00 00                              jp      0000h
BA48: C3 00 00                              jp      0000h
BA4B: C3 00 00                              jp      0000h
BA4E: C3 50 E6                  SOMERESET:  jp      EPROM_E650
BA51: C3 44 BD                              jp      GETCURSORADDR
                                
                                NUM_RETRY:
BA54: 05                            DB $05
                                
                                UNUSED_BYTE:
BA55: 31                            DB $31
                                
                                ; 10 bytes sent to port 7ah
                                INIT_SERIAL_DATA:
BA56: 01 00 02 00 03 C1 04 44       DB $01,$00,$02,$00,$03,$C1,$04,$44,$05,$68
BA5E: 05 68 
                                
                                EMPTY_OR_UNKNOWN:
BA60: 00 00 00 00 00 00 00 00       DB $00,$00,$00,$00,$00,$00,$00,$00
                                
                                DPH_TABLE:
                                    ; disk 0
BA68: A8 BA                         DW SKEWTABLE
BA6A: 00 00 00 00 00 00             DW $00,$00,$00 ; scratch pad bytes
BA70: 25 BE                         DW DIR_BUF
BA72: C2 BA                         DW DPB
BA74: 21 BF                         DW CSVAREA + 0*16
BA76: A5 BE                         DW ALVAREA + 0 * 31
                                
                                    ; disk 1
BA78: A8 BA                         DW SKEWTABLE
BA7A: 00 00 00 00 00 00             DW $00,$00,$00 ; scratch pad bytes
BA80: 25 BE                         DW DIR_BUF
BA82: C2 BA                         DW DPB
BA84: 31 BF                         DW CSVAREA + 1*16
BA86: C4 BE                         DW ALVAREA + 1 * 31
                                
                                    ; disk 2
BA88: A8 BA                         DW SKEWTABLE
BA8A: 00 00 00 00 00 00             DW $00,$00,$00 ; scratch pad bytes
BA90: 25 BE                         DW DIR_BUF
BA92: C2 BA                         DW DPB
BA94: 41 BF                         DW CSVAREA + 2*16
BA96: E3 BE                         DW ALVAREA + 2 * 31
                                
                                    ; disk 3
BA98: A8 BA                         DW SKEWTABLE
BA9A: 00 00 00 00 00 00             DW $00,$00,$00 ; scratch pad bytes
BAA0: 25 BE                         DW DIR_BUF
BAA2: C2 BA                         DW DPB
BAA4: 51 BF                         DW CSVAREA + 3*16
BAA6: 02 BF                         DW ALVAREA + 3 * 31
                                
                                SKEWTABLE:
BAA8: 01 07 0D 13 19 05 0B 11       DB $01,$07,$0D,$13,$19,$05,$0B,$11,$17,$03,$09,$0F,$15,$02,$08,$0E,$14,$1A,$06,$0C,$12,$18,$04,$0A,$10,$16
BAB0: 17 03 09 0F 15 02 08 0E 
BAB8: 14 1A 06 0C 12 18 04 0A 
BAC0: 10 16 
                                
                                DPB:
BAC2: 1A 00 03 07 00 F2 00 3F       DB $1A,$00,$03,$07,$00,$F2,$00,$3F,$00,$C0,$00,$10,$00,$02,$00
BACA: 00 C0 00 10 00 02 00 
                                
                                WBOOT:
BAD1: 31 80 00                      ld      sp,0080h
BAD4: 0E 00                         ld      c,00h
BAD6: CD 09 E8                      call    EPROM_SETDRIVE
BAD9: CD 00 E8                      call    EPROM_INITD
BADC: 06 2C                         ld      b,2Ch                      ; reads 44 sectors (only CCP)
BADE: 0E 00                         ld      c,00h
BAE0: 16 02                         ld      d,02h                      ; starting from sector 2
BAE2: 21 00 A4                      ld      hl,STARTCCP
                                
                                WBOOTLOOP:
BAE5: C5                            push    bc
BAE6: D5                            push    de
BAE7: E5                            push    hl
BAE8: 4A                            ld      c,d
BAE9: CD 06 E8                      call    EPROM_SETSECTOR
BAEC: E1                            pop     hl
BAED: E5                            push    hl
BAEE: CD 0C E8                      call    EPROM_SETDMA
BAF1: CD 12 E8                      call    EPROM_READSECTOR
BAF4: E1                            pop     hl
BAF5: 11 80 00                      ld      de,SECTORSIZE
BAF8: 19                            add     hl,de
BAF9: D1                            pop     de
BAFA: C1                            pop     bc
BAFB: 05                            dec     b
BAFC: 28 1B                         jr      z,WBOOTENDLOOP
BAFE: 14                            inc     d
BAFF: 7A                            ld      a,d
BB00: FE 1B                         cp      1Bh
BB02: 38 E1                         jr      c,WBOOTLOOP
BB04: 16 01                         ld      d,01h
BB06: 0C                            inc     c
BB07: C5                            push    bc
BB08: D5                            push    de
BB09: E5                            push    hl
BB0A: CD 03 E8                      call    EPROM_SETTRACK
BB0D: E1                            pop     hl
BB0E: D1                            pop     de
BB0F: C1                            pop     bc
BB10: 18 D3                         jr      WBOOTLOOP
                                
                                BOOT:
BB12: AF                            xor     a
BB13: 32 03 00                      ld      (IOBYTE),a
BB16: 32 04 00                      ld      (DEFDRIVE),a
                                
                                WBOOTENDLOOP:
BB19: 21 50 BB                      ld      hl,MESSAGE_DOS_22
BB1C: CD FA E3                      call    WRSTG
                                
BB1F: C5                            push    bc
BB20: 06 0A                         ld      b,0Ah
BB22: 21 56 BA                      ld      hl,INIT_SERIAL_DATA
                                
                                INIT_SERIAL:
BB25: 7E                            ld      a,(hl)
BB26: D3 7A                         out     (SERIAL),a
BB28: 23                            inc     hl
BB29: 05                            dec     b
BB2A: C2 25 BB                      jp      nz,INIT_SERIAL
                                
BB2D: C1                            pop     bc
                                
BB2E: 3E C3                         ld      a,0C3h
BB30: 32 00 00                      ld      (0000h),a
BB33: 21 03 BA                      ld      hl,WARMBOOT
BB36: 22 01 00                      ld      (0001h),hl       ; JP WARMBOOT at RST 0
                                
BB39: 32 05 00                      ld      (0005h),a        ;
BB3C: 21 06 AC                      ld      hl,SOMECCPCALL   ;
BB3F: 22 06 00                      ld      (0006h),hl       ; JP $AC06 at $0005
                                
BB42: 21 A5 BD                      ld      hl,BUFEPROM      ;
BB45: CD 0C E8                      call    EPROM_SETDMA     ; sets the EPROM DMA buffer
                                
BB48: FB                            ei
BB49: 3A 04 00                      ld      a,(DEFDRIVE)     ;
BB4C: 4F                            ld      c,a              ; sets cpm default drive
                                
BB4D: C3 00 A4                      jp      STARTCCP         ; starts
                                
                                MESSAGE_DOS_22:
BB50: 0D 0A 44 4F 53 20 32 2E       DB $0D,$0A, "DOS 2.2 48k",$0D,$0A
BB58: 32 20 34 38 6B 0D 0A 
BB5F: 72 65 76 2E 20 64 69 63       DB "rev. dic/81",$0D,$0A,$A0
BB67: 2F 38 31 0D 0A A0 
                                
                                ; Referenced from BBCF
                                ; TODO call directly
                                READKBD:
BB6D: C3 DC E3                      jp      KBDIN
                                
                                ; apparently not referenced, sends 0d 0a to video
                                ; TODO remove if dead code
                                LBB70:
BB70: 3E 0D                         ld      a,0Dh
BB72: CD 03 E4                      call    EPROM_PRTCHAR
BB75: 3E 0A                         ld      a,0Ah
BB77: CD 03 E4                      call    EPROM_PRTCHAR
BB7A: C9                            ret
                                
                                
                                ;***************************************************************************************
                                ;
                                ; CONST (function 2)
                                ; Returns its status in A; 0 if no character is ready, 0FFh if one is.
                                ;
                                ;***************************************************************************************
BB7B: 3A 03 00                  CONST: ld      a,(IOBYTE)
BB7E: E6 03                            and     03h
BB80: FE 01                            cp      01h                 ; is CON a CRT ?
BB82: 28 08                            jr      z,CONST_NOTCRT
BB84: DB FF                            in      a,(0FFh)
BB86: 07                               rlca                        ; test 7 bit of keyboard port
BB87: 3E FF                     LBB87: ld      a,0FFh
BB89: D0                        LBB89: ret     nc                  ; if 1 returns $FF
BB8A: AF                               xor     a                   ; if 0 returns $00
BB8B: C9                               ret
                                CONST_NOTCRT:
BB8C: AF                               xor     a
BB8D: D3 7A                            out     (SERIAL),a
BB8F: DB 7A                     LBB8F: in      a,(SERIAL)
BB91: E6 01                            and     01h                 ; bit 1 seriale => data ready
BB93: 37                        LBB93: scf
BB94: 28 F1                            jr      z,LBB87
BB96: 3F                               ccf
BB97: 18 EE                            jr      LBB87
                                
BB99: AF                        LBB99: xor     a
BB9A: D3 7A                     LBB9A: out     (SERIAL),a
BB9C: DB 7A                            in      a,(SERIAL)
BB9E: E6 04                            and     04h
BBA0: 18 F1                            jr      LBB93
                                
                                ;***************************************************************************************
                                ;
                                ;LISTST (function 15)
                                ;Return status of current printer device.
                                ;
                                ;Returns A=0 (not ready) or A=0FFh (ready).
                                ;
                                ;***************************************************************************************
                                
                                LISTST:
BBA2: 3A 03 00                      ld      a,(IOBYTE)
BBA5: E6 C0                         and     0C0h
BBA7: 28 0B                         jr      z,LBBB4
BBA9: FE 40                         cp      40h     ; '@'
BBAB: 28 EC                         jr      z,LBB99
BBAD: FE 80                         cp      80h
BBAF: 28 03                         jr      z,LBBB4
BBB1: AF                            xor     a
BBB2: 18 11                         jr      LBBC5
                                LBBB4:
BBB4: DB 5D                         in      a,(5Dh) ; ']'
BBB6: 07                            rlca
BBB7: 07                            rlca
BBB8: FD 2A 03 E0                   ld      iy,(0E003h)
BBBC: 47                            ld      b,a
BBBD: FD 7E 06                      ld      a,(iy+06h)
BBC0: EE 04                         xor     04h
BBC2: A0                            and     b
BBC3: E6 C0                         and     0C0h
                                
                                ; Referenced from BBB2
                                LBBC5:
BBC5: 2F                            cpl
BBC6: 18 BF                         jr      LBB87
                                
                                ;***************************************************************************************
                                ;
                                ;READER (function 7)
                                ;Read a character from the "paper tape reader" - or whatever the current auxiliary device is. If the device isn't ready, wait until it is. The character will be returned in A. If this device isn't implemented, return character 26 (^Z).
                                ;
                                ;***************************************************************************************
                                
                                READER:
BBC8: 3A 03 00                      ld      a,(IOBYTE)
BBCB: E6 03                         and     03h
BBCD: FE 01                         cp      01h
BBCF: 20 9C                         jr      nz,READKBD
                                
                                READER_SERIAL:
BBD1: AF                            xor     a
BBD2: D3 7A                         out     (SERIAL),a ; 'z'
BBD4: DB 7A                         in      a,(SERIAL) ; 'z'
BBD6: E6 01                         and     01h
BBD8: CA D1 BB                      jp      z,READER_SERIAL
BBDB: DB 78                         in      a,(78h) ; 'x'
BBDD: C9                            ret
                                
                                ; Referenced from BA0C
BBDE: CD 91 BC                  CONOUT: call    SAVE_REGS
BBE1: 3A 03 00                         ld      a,(IOBYTE)
BBE4: E6 03                            and     03h
BBE6: FE 01                            cp      01h
BBE8: 28 0A                            jr      z,LBBF4
BBEA: FE 02                            cp      02h
BBEC: 28 29                            jr      z,LBC17
                                       ; Referenced from BC15
                                       ; --- START PROC LBBEE ---
BBEE: 79                        LBBEE: ld      a,c
BBEF: CD 03 E4                         call    EPROM_PRTCHAR
BBF2: 18 27                            jr      LBC1B
                                       ; Referenced from BBE8, BBFB, BC0F
                                       ; --- START PROC LBBF4 ---
BBF4: AF                        LBBF4: xor     a
BBF5: D3 7A                            out     (SERIAL),a ; 'z'
BBF7: DB 7A                            in      a,(SERIAL) ; 'z'
BBF9: E6 04                            and     04h
BBFB: CA F4 BB                         jp      z,LBBF4
BBFE: 79                               ld      a,c
BBFF: D3 78                            out     (78h),a ; 'x'
BC01: 18 18                            jr      LBC1B
                                
                                
                                ; Referenced from BA0F, BA12
BC03: CD 91 BC                  LIST:  call    SAVE_REGS
BC06: 3A 03 00                         ld      a,(IOBYTE)
BC09: E6 C0                            and     0C0h
BC0B: 28 0A                            jr      z,LBC17
BC0D: FE 40                            cp      40h     ; '@'
BC0F: 28 E3                            jr      z,LBBF4
BC11: FE 80                            cp      80h
BC13: 28 02                            jr      z,LBC17
BC15: 18 D7                            jr      LBBEE
                                       ; Referenced from BBEC, BC0B, BC13
                                       ; --- START PROC LBC17 ---
                                LBC17:
BC17: 79                               ld      a,c
BC18: CD 4E BA                         call    SOMERESET
                                       ; Referenced from BBF2, BC01
                                       ; --- START PROC LBC1B ---
BC1B: 18 70                     LBC1B: jr      LOAD_REGS2
                                
                                
                                ; Referenced from BA18
BC1D: 0E 00                     HOME:  ld      c,00h
BC1F: CD 3F BC                         call    SETTRK
BC22: 0E 00                            ld      c,00h
BC24: 18 1E                            jr      SETSEC
                                
                                
                                ; returns the address of a Disc Parameter Header in HL.
                                ; The exact format of a DPH varies between CP/M versions;
                                ; If the disc could not be selected it returns HL=0.
                                ; Referenced from BA1B
                                SELDSK:
BC26: 21 00 00                      ld      hl,0000h
BC29: 79                            ld      a,c
BC2A: 32 DC BF                      ld      (CURRDRIVE),a
BC2D: FE 04                         cp      04h
BC2F: D0                            ret     nc
BC30: 3A DC BF                      ld      a,(CURRDRIVE)
BC33: 6F                            ld      l,a
BC34: 26 00                         ld      h,00h
BC36: 29                            add     hl,hl
BC37: 29                            add     hl,hl
BC38: 29                            add     hl,hl
BC39: 29                            add     hl,hl
BC3A: 11 68 BA                      ld      de,DPH_TABLE
BC3D: 19                            add     hl,de                      ; hl = DPH_TABLE[CURRDRIVE*16]
BC3E: C9                            ret
                                
                                SETTRK:                                   ; Referenced from BA1E, BC1F
BC3F: 79                            ld      a,c
BC40: 32 DA BF                      ld      (CURRTRACK),a
BC43: C9                            ret
                                
                                SETSEC:                                   ; Referenced from BA21, BC24
BC44: 79                            ld      a,c
BC45: 32 DB BF                      ld      (CURRSEC),a
BC48: C9                            ret
                                
                                ; Translate sector numbers to take account of skewing.
                                ; On entry, BC=logical sector number (zero based) and DE=address
                                ; of translation table. On exit, HL contains physical sector number.
                                ; On a system with hardware skewing, this would normally ignore DE
                                ; and return either BC or BC+1.
                                ; Referenced from BA30
                                SECTRAN:
BC49: EB                            ex      de,hl
BC4A: 09                            add     hl,bc
BC4B: 6E                            ld      l,(hl)
BC4C: 26 00                         ld      h,00h                     ; hl = DE[BC]
BC4E: C9                            ret
                                
                                ; Referenced from BA24
                                SETDMA:
BC4F: ED 43 DE BF                   ld      (DMA_ADDR),bc
BC53: C9                            ret
                                
                                ;
                                ; Read the currently set track and sector at the current DMA address.
                                ; Returns A=0 for OK, 1 for unrecoverable error, 0FFh if media changed.
                                ;
                                READ:
BC54: CD 91 BC                      call    SAVE_REGS                 ; Referenced from BA27
BC57: CD D4 BC                      call    CHECK_CHANGED_TRKSEC
BC5A: CD 12 E8                      call    EPROM_READSECTOR
BC5D: CD C3 BC                      call    DISKBUF_TO_CPMBUF
BC60: AF                            xor     a
BC61: 18 2A                         jr      LOAD_REGS2
                                
                                WRITE:
BC63: CD 91 BC                      call    SAVE_REGS                 ; Referenced from BA2A
BC66: CD D4 BC                      call    CHECK_CHANGED_TRKSEC
BC69: 3A 54 BA                      ld      a,(NUM_RETRY)
BC6C: F5                            push    af
                                
                                WRITE_RETRY:                          ; Referenced from BC89
BC6D: CD BB BC                      call    CPMBUF_TO_DISKBUF
BC70: CD 0F E8                      call    EPROM_WRITESECTOR
BC73: 3A 54 BA                      ld      a,(NUM_RETRY)
BC76: FE 00                         cp      00h                   ; do not verify if 0
BC78: 28 12                         jr      z,WRITE_RETRY_EXIT    ;
BC7A: CD F6 BC                      call    VERIFY_SECTOR         ; verify sector written
BC7D: B7                            or      a
BC7E: 28 0C                         jr      z,WRITE_RETRY_EXIT    ; verify ok => exit
BC80: 21 30 BD                      ld      hl,MSGRETRY           ; prints error message
BC83: CD FA E3                      call    WRSTG                 ;
BC86: F1                            pop     af
BC87: 3D                            dec     a                     ; decrease number of attempts
BC88: F5                            push    af
BC89: 20 E2                         jr      nz,WRITE_RETRY        ; retry
BC8B: 3C                            inc     a
                                
                                WRITE_RETRY_EXIT:                    ; Referenced from BC78, BC7E
BC8C: C1                            pop     bc
                                
                                LOAD_REGS2:                          ; Referenced from BC1B, BC61
BC8D: CD A9 BC                      call    LOAD_REGS
BC90: C9                            ret
                                
                                SAVE_REGS:                           ; Referenced from BBDE, BC03, BC54, BC63
BC91: ED 73 D0 BF                   ld      (TMPREGSP),sp
BC95: 22 D2 BF                      ld      (TMPREGHL),hl
BC98: ED 53 D4 BF                   ld      (TMPREGDE),de
BC9C: ED 43 D6 BF                   ld      (TMPREGBC),bc
BCA0: 32 D8 BF                      ld      (TMPREGA),a
BCA3: D1                            pop     de
BCA4: 31 D0 BF                      ld      sp,TMPREGSP
BCA7: D5                            push    de
BCA8: C9                            ret
                                
                                ; Referenced from BC8D
                                LOAD_REGS:
BCA9: E1                            pop     hl
BCAA: ED 7B D0 BF                   ld      sp,(TMPREGSP)
BCAE: E3                            ex      (sp),hl
BCAF: ED 4B D6 BF                   ld      bc,(TMPREGBC)
BCB3: ED 5B D4 BF                   ld      de,(TMPREGDE)
BCB7: 2A D2 BF                      ld      hl,(TMPREGHL)
BCBA: C9                            ret
                                
                                CPMBUF_TO_DISKBUF:                  ; Referenced from BC6D
BCBB: 11 A5 BD                      ld      de,BUFEPROM
BCBE: 2A DE BF                      ld      hl,(DMA_ADDR)
BCC1: 18 07                         jr      START_COPYBUF
                                
                                DISKBUF_TO_CPMBUF:                  ; Referenced from BC5D
BCC3: 11 A5 BD                      ld      de,BUFEPROM
BCC6: 2A DE BF                      ld      hl,(DMA_ADDR)
BCC9: EB                            ex      de,hl
                                
                                START_COPYBUF:
BCCA: 06 80                         ld      b,SECTORSIZE
                                COPY_LOOP:
BCCC: 7E                            ld      a,(hl)
BCCD: 2F                            cpl                   ; invert data from WDC 1791 /D0-/D7
BCCE: 12                            ld      (de),a
BCCF: 23                            inc     hl
BCD0: 13                            inc     de
BCD1: 10 F9                         djnz    COPY_LOOP
BCD3: C9                            ret
                                
                                CHECK_CHANGED_TRKSEC:                     ; Referenced from BC57, BC66
BCD4: 3A DC BF                      ld      a,(CURRDRIVE)
BCD7: 4F                            ld      c,a
BCD8: 3A DD BF                      ld      a,(LAST_DRIVE)
BCDB: B9                            cp      c
BCDC: 79                            ld      a,c
BCDD: 32 DD BF                      ld      (LAST_DRIVE),a
BCE0: C4 09 E8                      call    nz,EPROM_SETDRIVE
BCE3: 3A DB BF                      ld      a,(CURRSEC)
BCE6: 4F                            ld      c,a
BCE7: CD 06 E8                      call    EPROM_SETSECTOR
BCEA: 3A DA BF                      ld      a,(CURRTRACK)
BCED: 4F                            ld      c,a
BCEE: 3A EC BF                      ld      a,(LAST_TRACK)
BCF1: B9                            cp      c
BCF2: C4 03 E8                      call    nz,EPROM_SETTRACK
BCF5: C9                            ret
                                
                                ; Referenced from BC7A
                                VERIFY_SECTOR:
BCF6: CD 2A E8                      call    EPROM_E82A
BCF9: 0E BF                         ld      c,FDCDATA           ; port to be used in "ini"
BCFB: DD 66 0B                      ld      h,(ix+0Bh)
BCFE: DD 6E 0A                      ld      l,(ix+0Ah)
BD01: 3E 7F                         ld      a,7Fh
BD03: D3 BC                         out     (FDCCMD),a
BD05: 18 02                         jr      LBD09
                                
                                VERIFY_SECTOR_DMA_LOOP:
                                ; Referenced from BD0C, BD11, BD16, BD1B
BD07: ED A2                     LBD07: ini
BD09: DB 3F                     LBD09: in      a,(DRIVESEL) ; '?'               ; Referenced from BD05, BD1E
BD0B: 07                               rlca
BD0C: 38 F9                            jr      c,LBD07
BD0E: DB 3F                            in      a,(DRIVESEL) ; '?'
BD10: 07                               rlca
BD11: 38 F4                            jr      c,LBD07
BD13: DB 3F                            in      a,(DRIVESEL) ; '?'
BD15: 07                               rlca
BD16: 38 EF                            jr      c,LBD07
BD18: DB 3F                            in      a,(DRIVESEL) ; '?'
BD1A: 07                               rlca
BD1B: 38 EA                            jr      c,LBD07
BD1D: 07                               rlca
BD1E: 30 E9                            jr      nc,LBD09
BD20: DB 3F                     LBD20: in      a,(DRIVESEL) ; '?'              ; Referenced from BD24
BD22: CB 77                            bit     6,a
BD24: 28 FA                            jr      z,LBD20
BD26: DB BC                            in      a,(FDCCMD)
BD28: 2F                               cpl
BD29: DD 77 0F                         ld      (ix+0Fh),a
BD2C: DD A6 0D                         and     (ix+0Dh)
BD2F: C9                               ret
                                
                                ; Message "\r\nDISK WRITE RETRY\r", $A0
                                MSGRETRY:
BD30: 0D 0A 44 49 53 4B 20 57       DB $0D, $0A, "DISK WRITE RETRY", $0A, $A0
BD38: 52 49 54 45 20 52 45 54 
BD40: 52 59 0A A0 
                                
                                ; gets cursor address in HL
                                ; by reading it from the pointer
                                ; stored in the VDD table
                                ; Referenced from jump table
                                GETCURSORADDR:
BD44: DD 21 E0 BF                   ld      ix,VDDTABLE
BD48: DD 66 01                      ld      h,(ix+01h)
BD4B: DD 6E 00                      ld      l,(ix+00h)
BD4E: 11 05 00                      ld      de,0005h
BD51: 19                            add     hl,de
BD52: 56                            ld      d,(hl)
BD53: 23                            inc     hl
BD54: 66                            ld      h,(hl)
BD55: 6A                            ld      l,d
BD56: C9                            ret
                                
                                ; Referenced from BD59, BD62
                                AUTOEXEC_STRING_ADDR:
BD57: 6F BD                         DW MESSAGE_INIZIO_LAVORO
                                
                                ;***************************************************************************************
                                ;
                                ;CONIN (function 3)
                                ;Wait until the keyboard is ready to provide a character, and return it in A.
                                ;
                                ;***************************************************************************************
                                
                                CONIN:
BD59: 2A 57 BD                      ld      hl,(AUTOEXEC_STRING_ADDR)
BD5C: 7E                            ld      a,(hl)
BD5D: B7                            or      a
BD5E: FA 66 BD                      jp      m,RESTORE_CONIN_VECTOR
BD61: 23                            inc     hl
BD62: 22 57 BD                      ld      (AUTOEXEC_STRING_ADDR),hl
BD65: C9                            ret
                                
                                RESTORE_CONIN_VECTOR:
BD66: 21 DC E3                      ld      hl,KBDIN
BD69: 22 0A BA                      ld      (FCONIN+1),hl   ; change JP CONIN vector to JP KBDIN
BD6C: E6 7F                         and     7Fh             ; clean 7th bit
BD6E: C9                            ret
                                
                                ; STRING "Inizio Lavoro"
                                MESSAGE_INIZIO_LAVORO:
BD6F: 49 6E 69 7A 69 6F 20 4C       DB "Inizio Lavoro",$8D,$00,$00,$00
BD77: 61 76 6F 72 6F 8D 00 00 
BD7F: 00 
                                
                                EMPTY_ZONE_37B:
BD80: [37 bytes]                    DS 37
                                
                                ; (128 bytes) sector buffer for disk eprom routines
                                BUFEPROM:
BDA5: [128 bytes]                   DS 128
                                
                                ; 127 bytes buffer for containing the directory
                                DIR_BUF:
BE25: [128 bytes]                   DS 128
                                
                                ; scratch pad area used by the BDOS to keep disk storage allocation information
                                ALVAREA:
BEA5: [31 bytes]                    DS 31
BEC4: [31 bytes]                    DS 31
BEE3: [31 bytes]                    DS 31
BF02: [31 bytes]                    DS 31
                                
                                ; scratch pad area used for software check for changed disks
                                CSVAREA:
BF21: [16 bytes]                    DS 16
BF31: [16 bytes]                    DS 16
BF41: [16 bytes]                    DS 16
BF51: [16 bytes]                    DS 16
                                
                                EMPTY_111:
BF61: [111 bytes]                   DS 111
                                
BFD0: 00 00                     TMPREGSP:    DW 0    ; saves sp register
BFD2: 00 00                     TMPREGHL:    DW 0    ; saves hl register
BFD4: 00 00                     TMPREGDE:    DW 0    ; saves de register
BFD6: 00 00                     TMPREGBC:    DW 0    ; saves bc register
BFD8: 00                        TMPREGA:     DB 0    ; saves a register
BFD9: 00                        EMPTY_BF:    DB 0    ; empty
BFDA: 00                        CURRTRACK:   DB 0    ; current track
BFDB: 00                        CURRSEC:     DB 0    ; current sector
BFDC: 00                        CURRDRIVE:   DB 0    ; current drive number (0..3)
BFDD: 00                        LAST_DRIVE:  DB 0    ; last used drive
BFDE: 00 00                     DMA_ADDR:    DW 0    ; saves CPM DMA buffer
                                
                                LAST_BYTE_BEFORE_VIDEO:
                                
                                

                                ---------------------------------

                                
                                
                                
                                
                                
                                

BFE0:
